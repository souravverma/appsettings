import Harness3dDesignSolutionModel from "../models/Harness3dDesignSolution.model";
import Branch3DModel from "../models/Branch3d.model";
import PartZoneModel from "../models/Partzone.model";
import CoveringElement3d from "../models/CoveringElement3d.model";
import FunctionalItem3dSolutionPartZoneRelation from "../models/FunctionalItem3dSolutionPartZoneRelation.model";
import Branch3dExtremitySolutionModel from "../models/Branch3dExtremitySolution.model";
import FunctionalItem3dSolutionModel from "../models/FunctionalItem3dSolution.model";
import ComponentModel from "../models/Component.model";
import MarkerComponentModel from "../models/markerComponent.model";
import RouteCategoryModel from "../models/RouteCategory.model";
import FunctionalItemModel from "../models/FunctionalItem.model";
import CircuitModel from "../models/Circuit.model";
import BranchPointDefinitionModel from "../models/BranchPointDefinition.model";

class Pnode {
  number: number;
  db_id: number;
  db_id2: number; // case of x-ref nodes
  name: string;
  x: number;
  y: number;
  z: number;
}

class Pedge {
  number: number;
  length: number;
  forced_length: number;
  db_id: number;
  name: string;
  node1: Pnode;
  node2: Pnode;
  constructor(my_node1: Pnode, my_node2: Pnode) {
    this.node1 = my_node1;
    this.node2 = my_node2;
  }
}

class Pwaypoint {
  id: number;
  db_id: number;
  positionX: number;
  positionY: number;
  positionZ: number;
  directionX: number;
  directionY: number;
  directionZ: number;
}

class Graph {
  nodes: Pnode[] = [];
  edges: Pedge[] = [];

  constructor() {
    this.edges = [];
    this.nodes = [];
  }

  addNode(my_node: Pnode) {
    this.nodes.push(my_node);
  }

  addEdge(my_edge: Pedge) {
    this.edges.push(my_edge);
  }
  removeNode(rem_node: Pnode) {
    const index = this.nodes.indexOf(rem_node);
    if (index > -1) {
      this.nodes.splice(index, 1);
      return true;
    } else return false;
  }
  removeEdge(rem_edge: Pedge) {
    const index = this.edges.indexOf(rem_edge);
    if (index > -1) {
      this.edges.splice(index, 1);
      return true;
    } else return false;
  }
  displayNodes() {
    this.nodes.forEach((node) => {
      console.log("node is", node.name);
    });
  }
  displayEdges() {
    this.edges.forEach((edge) => {
      console.log("edge is", edge.name);
    });
  }

  getConnectedEdges(my_node: Pnode) {
    const my_edges: Pedge[] = [];
    this.edges.forEach((edge) => {
      if (
        my_node.number == edge.node1.number ||
        my_node.number == edge.node2.number
      ) {
        my_edges.push(edge);
      }
    });
    return my_edges;
  }
}

export default class CapitalHX2MLGenerationService {
  public bundleB3DMapping = new Map();

  static instance: CapitalHX2MLGenerationService;
  static activate_insulation_run = true;
  protected option_include_non_extractible_branch = "noNE";
  protected option_remove_small_branches = true;
  protected option_merge_protections = true;
  protected moveTopVal: number[];
  protected routes: string[];
  protected option_branch_point = true;

  constructor() {
    // This is intentional
  }

  public setOptions(
    op_include_non_extractible: string,
    op_remove_small_br: boolean,
    op_merge_protections: boolean,
    moveTopVal: number[],
    routes: string[],
    branch_point: boolean
  ) {
    if (op_include_non_extractible == undefined)
      op_include_non_extractible = "noNE";
    this.option_include_non_extractible_branch = op_include_non_extractible;
    if (op_remove_small_br == undefined) op_remove_small_br = false;
    this.option_remove_small_branches = op_remove_small_br;
    if (op_merge_protections == undefined) op_merge_protections = false;
    this.option_merge_protections = op_merge_protections;
    if (moveTopVal) this.moveTopVal = moveTopVal;
    if (routes) this.routes = routes;
    if (branch_point == undefined) branch_point = false;
    this.option_branch_point = branch_point;
    console.log(
      "options value in SET",
      this.option_include_non_extractible_branch,
      this.option_remove_small_branches,
      this.option_merge_protections
    );
  }

  static getInstance() {
    if (CapitalHX2MLGenerationService.instance)
      return CapitalHX2MLGenerationService.instance;
    else {
      CapitalHX2MLGenerationService.instance =
        new CapitalHX2MLGenerationService();
      return CapitalHX2MLGenerationService.instance;
    }
  }

  // method dedicated to create the BASE of the HX2ML file at harness level
  public async createBaseHX2MLfile(
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[]
  ) {
    const xMLSerializer = require("xmlserializer");
    const DOMParser = require("xmldom").DOMParser;
    const xmlDoc =
      '"<!-- Generated by CoreElec Bridge  --> "' +
      '"<!-- Capital Build Number : 2019.1 1SP1912.63 -->"' +
      '"<harnessdesign></harnessdesign>"';
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlDoc, "application/xml");

    const harnessdesign = doc.getElementsByTagName("harnessdesign")[0];
    harnessdesign.setAttribute(
      "xmlns",
      "http://www.mentor.com/harness/Schema/bridgesharness"
    );
    harnessdesign.setAttribute(
      "xmlns:brcnt",
      "http://www.mentor.com/harness/Schema/bridgesconnectivity"
    );
    harnessdesign.setAttribute(
      "xmlns:xsi",
      "http://www.w3.org/2001/XMLSchema-instance"
    );
    harnessdesign.setAttribute(
      "xsi:schemaLocation",
      "http://www.mentor.com/harness/Schema/bridgesharness dtd/bridgesharness.xsd"
    );
    harnessdesign.setAttribute("schemaVersion", "3_1");
    harnessdesign.setAttribute("author", "Capital-Bridges");
    harnessdesign.setAttribute("creationDate", "2020-5-13");
    harnessdesign.setAttribute("creationTime", "13:32:14");
    harnessdesign.setAttribute(
      "name",
      harness3dDesignSolution.adapDesignSolutionNumber
    );
    harnessdesign.setAttribute("originsystem", "CoreElec");

    const plane = doc.createElement("plane");
    plane.setAttribute(
      "xmlns",
      "http://www.mentor.com/harness/Schema/bridgesharness"
    );
    const center = doc.createElement("center");
    // we fetch the respective indexes aligned to moveToplogy list
    // declared in format {center_x,y,z (in mm), normal_x,y,z}
    const center_x = this.moveTopVal[0];
    const center_y = this.moveTopVal[1];
    const center_z = this.moveTopVal[2];
    center_x != -1
      ? center.setAttribute("x", -center_x / 1000)
      : center.setAttribute("x", "0");
    center_y != -1
      ? center.setAttribute("y", -center_y / 1000)
      : center.setAttribute("y", "0");
    center_z != -1
      ? center.setAttribute("z", -center_z / 1000)
      : center.setAttribute("z", "0");

    plane.appendChild(center);

    const normal = doc.createElement("normal");
    const normal_deg = this.moveTopVal[3]; //fetching the X-translation degree
    // should be considered in (-180-180) range
    if (normal_deg >= -180 && normal_deg <= 180) {
      // compute the degree in radians
      // set normal x,y,z as { 0,-sin(angle),cos(angle) }
      const normal_rad: number = (normal_deg * Math.PI) / 180;
      const normal_y = -Math.sin(normal_rad);
      const normal_z = Math.cos(normal_rad);
      normal.setAttribute("x", "0");
      normal.setAttribute("y", Math.round(normal_y * 100000) / 100000); //round upto 5 decimal places
      normal.setAttribute("z", Math.round(normal_z * 100000) / 100000);
    } else {
      normal.setAttribute("x", "0");
      normal.setAttribute("y", "0");
      normal.setAttribute("z", "1");
    }

    plane.appendChild(normal);

    const firstdirection = doc.createElement("firstdirection");
    firstdirection.setAttribute("x", "1");
    firstdirection.setAttribute("y", "0");
    firstdirection.setAttribute("z", "0");
    plane.appendChild(firstdirection);

    const harness = doc.createElement("harness");
    harness.setAttribute(
      "xmlns",
      "http://www.mentor.com/harness/Schema/bridgesharness"
    );
    harness.setAttribute("id", "Harness");
    harness.setAttribute(
      "partnumber",
      harness3dDesignSolution.adapDesignSolutionNumber
    );

    const myGraph = new Graph();
    this.createNodesHX2MLfile(
      doc,
      harness,
      harness3dDesignSolution,
      MyPartZones,
      myGraph
    );
    const bundleObj = this.createBundlesHX2MLfile(
      doc,
      harness,
      harness3dDesignSolution,
      MyPartZones,
      myGraph,
      this.routes
    );
    await this.createProtectionHX2MLfile(
      doc,
      harness,
      harness3dDesignSolution,
      MyPartZones,
      myGraph
    );

    const wiringconnectivity = doc.createElement("wiringconnectivity");
    wiringconnectivity.setAttribute(
      "xmlns",
      "http://www.mentor.com/harness/Schema/bridgesharness"
    );
    await this.createConnectorHX2MLfile(
      doc,
      wiringconnectivity,
      harness3dDesignSolution,
      MyPartZones,
      myGraph
    );
    // ADD LITTLE BRANCH when connector linked to several branches
    this.addLittleBranch(
      doc,
      harness,
      harness3dDesignSolution,
      MyPartZones,
      myGraph
    );
    // Filter based on searched routes
    if (this.routes && this.routes.length)
      await this.filterOnRoutes(harness, wiringconnectivity, bundleObj);
    harnessdesign.appendChild(plane);
    harnessdesign.appendChild(harness);
    harnessdesign.appendChild(wiringconnectivity);
    return xMLSerializer.serializeToString(doc);
    // return doc;
  }
  // method dedicated to fetch protection type(typecode)
  getCoveringElemType(coveringEle: CoveringElement3d): string {
    let typecode = "";
    if (coveringEle.cvrgElemType.name == "LACING_TAPE") {
      if (coveringEle.component && coveringEle.component.partNumber)
        typecode = coveringEle.component.partNumber;
    } else {
      const protection_types = coveringEle.name.split(".");
      typecode = protection_types[0];
    }
    if (typecode.search("BRA") >= 0) {
      typecode = typecode.slice(8);
    }
    if (typecode.search("undefined-") >= 0) {
      typecode = typecode.slice(10);
    }
    if (typecode.search("_Greater2m") >= 0) {
      typecode = typecode.slice(0, typecode.search("_Greater2m"));
    }
    if (typecode.search("_Lower2m") >= 0) {
      typecode = typecode.slice(0, typecode.search("_Lower2m"));
    }
    return typecode;
  }
  //method dedicated to setProtection attributes
  setProtectionAttributes(
    protection: any,
    protAttr: any,
    coveringEle: CoveringElement3d,
    is_fixing_element: boolean
  ) {
    protection.setAttribute(
      "name",
      protAttr.adapDsNumber + "_" + protAttr.protectionDisName
    );
    protection.setAttribute("displayName", protAttr.protectionDisName);
    protection.setAttribute("id", protAttr.prId);
    protection.setAttribute("partnumber", protAttr.typecode);
    if (is_fixing_element) {
      protection.setAttribute("fixingType", "other");
      protection.setAttribute("materialcode", "-");
    } else {
      protection.setAttribute("insulationType", "tape");
      protection.setAttribute("subType", "unknown");
      protection.setAttribute("typeCode", protAttr.typecode);
      protection.setAttribute("tapeWidth", 0);
      protection.setAttribute("tapeThickness", 0);
      protection.setAttribute("tapeLayersCount", 0);
      protection.setAttribute("tapeAngle", 0);
      protection.setAttribute("tapeLength", 0);
      const diameterM = coveringEle.diameterMm / 1000;
      protection.setAttribute("innerDiameter", diameterM);
      const lengthM = coveringEle.lengthMm / 1000;
      protection.setAttribute("length", lengthM);
    }
  }
  //method to set protection properties
  setProtectionProperties(
    doc: any,
    protection: any,
    is_fixing_element: boolean,
    coveringEle: CoveringElement3d,
    typecode: string
  ) {
    if (coveringEle.component != null) {
      this.createProperty("CATIA_TYPE", "", protection, doc);

      this.createProperty(
        "LONG_PART_NUMBER",
        coveringEle.component.partNumber,
        protection,
        doc
      );

      this.createProperty("SHORT_PART_NUMBER", typecode, protection, doc);
    }
    if (is_fixing_element) {
      if (coveringEle.cvrgElemType != null) {
        this.createProperty(
          "FIXING_TYPE",
          coveringEle.cvrgElemType.name,
          protection,
          doc
        );
      }
    } else {
      if (coveringEle.cvrgElemType != null) {
        this.createProperty(
          "COVERING_TYPE",
          coveringEle.cvrgElemType.name,
          protection,
          doc
        );
      }
      if (coveringEle.lengthMm != null) {
        const lengthMm = coveringEle.lengthMm;
        this.createProperty("LENGTH", lengthMm, protection, doc);
      }

      if (coveringEle.diameterMm != null) {
        const diameterMm = coveringEle.diameterMm;
        this.createProperty("INNER_DIAMETER", diameterMm, protection, doc);
      }
    }
    if (coveringEle.printedLabel1 != null && coveringEle.printedLabel1 != "") {
      this.createProperty(
        "PRINTED_LABEL_1",
        coveringEle.printedLabel1,
        protection,
        doc
      );
    }
    if (coveringEle.printedLabel2 != null && coveringEle.printedLabel2 != "") {
      this.createProperty(
        "PRINTED_LABEL_2",
        coveringEle.printedLabel2,
        protection,
        doc
      );
    }
    if (coveringEle.printedLabel3 != null && coveringEle.printedLabel3 != "") {
      this.createProperty(
        "PRINTED_LABEL_3",
        coveringEle.printedLabel3,
        protection,
        doc
      );
    }
  }
  //method to store all componentIDs linked to protections
  fillComponentIds(MyPartZones: any) {
    const ComponentIds: number[] = [];
    // perfo optimisation : collect all components IDs attached to the protections in one shot
    // scan all partzones of DS
    for (const pz of MyPartZones) {
      // scan all branches related to partzone
      for (const br of pz.b3d) {
        // search for all covering_element on branches
        for (const coveringEle of br.cvrgElem) {
          if (coveringEle.component != null) {
            const compId = coveringEle.component.id;
            // store all components IDs linked to all protections
            if (ComponentIds.indexOf(compId) < 0) {
              ComponentIds.push(compId);
            }
          }
        }
      }
    }
    return ComponentIds;
  }
  // method dedicated to create the PROTECTIONs & MARKERs of the HX2ML file
  public async createProtectionHX2MLfile(
    doc: any,
    harness: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[],
    myGraph: Graph
  ) {
    //object to store various element indexes
    const elementIndex = { protectionIndex: 0, fixingIndex: 0, runIndex: 0 };
    let insulExists = false; // variable to track if insulationRun is created/not
    console.log("covering elem: creation");

    const ComponentIds: number[] = this.fillComponentIds(MyPartZones);
    // scan all partzones of DS followed by branch and coverElem
    // retrieve the components that are fixing elements
    const fixingElements: ComponentModel[] = await this.getFixingElements(
      ComponentIds
    );
    console.log("fixingsfound : " + fixingElements.length);
    const tab_protection_names: string[] = [];
    let seq_no = 1;
    // list of already processed covering elem
    const covering_elems: number[] = [];
    // scan all partzones of DS
    for (const pz of MyPartZones) {
      // scan all branches related to partzone
      for (const br of pz.b3d) {
        // search for all covering_element on branches
        for (const coveringEle of br.cvrgElem) {
          // we check the covering elem is not treated via another branch
          if (covering_elems.indexOf(coveringEle.id) < 0) {
            covering_elems.push(coveringEle.id);
            // check if the covering element is a fixing element
            let is_fixing_element = false;
            if (coveringEle.component != null) {
              const compId = coveringEle.component.id;
              // search if the comp id is in the list of the fixing elements
              if (fixingElements.find((f) => f.id === compId) != undefined) {
                is_fixing_element = true;
              }
            }
            // we need to store the protection type code in coreelec.
            // Today it is a workaround to find it from the protection name
            const typecode = this.getCoveringElemType(coveringEle);
            // suppress this method for perfo optimisation - now only one request to DB for all fixings
            // const is_fixing_element = await this.isProtectionAFixingElement (typecode);
            let covering_string = "";
            let covering_index = 0;
            if (is_fixing_element) {
              covering_string = "fixing";
              elementIndex.fixingIndex++;
              covering_index = elementIndex.fixingIndex;
            } else {
              covering_string = "protection";
              elementIndex.protectionIndex++;
              covering_index = elementIndex.protectionIndex;
            }
            let protection = doc.createElement(covering_string);
            let protection1 = null;
            const branches: string[] = [];
            // create protection attribute
            let protectionDisName = pz.userArea.name;
            // when protection cover more than one branches replace undefined by list of branches
            if (coveringEle.name.includes("undefined")) {
              coveringEle.branch.forEach((b3d) => {
                branches.push(b3d.name);
              });
              branches.sort();
              branches.forEach((branch) => {
                protectionDisName = protectionDisName + "-" + branch;
              });
              protectionDisName = protectionDisName + coveringEle.name.slice(9);
            } else {
              protectionDisName = protectionDisName + "-" + coveringEle.name;
            }
            // ensure the unicity of the protection names
            if (tab_protection_names.includes(protectionDisName)) {
              protectionDisName = protectionDisName + "_" + seq_no;
              seq_no = seq_no + 1;
            }
            tab_protection_names.push(protectionDisName);
            const protAttr = {
              protectionDisName: protectionDisName,
              prId: covering_string + covering_index,
              typecode: typecode,
              adapDsNumber: harness3dDesignSolution.adapDesignSolutionNumber,
            };
            this.setProtectionAttributes(
              protection,
              protAttr,
              coveringEle,
              is_fixing_element
            );
            // if protection is a sleeve we create an insulation run
            if (
              coveringEle.cvrgElemType.name == "SLEEVE" ||
              coveringEle.cvrgElemType.name == "LACING_TAPE"
            ) {
              elementIndex.runIndex++;
              const run_string = "insulationRun";
              protection.setAttribute(
                "insulationrun",
                run_string + elementIndex.runIndex
              );
              insulExists = true;
              protection1 = protection;
              protection = doc.createElement(run_string);
              protection.setAttribute(
                "name",
                "RUN_" +
                  harness3dDesignSolution.adapDesignSolutionNumber +
                  "_" +
                  protectionDisName
              );
              protection.setAttribute(
                "displayName",
                "RUN_" + protectionDisName
              );
              protection.setAttribute("id", run_string + elementIndex.runIndex);
            }
            // create protection extremities
            const covering_consistent: boolean =
              // eslint-disable-next-line
              await this.createProtectionHX2MLExtremities(
                doc,
                protection,
                covering_index,
                coveringEle,
                is_fixing_element,
                myGraph
              );

            // create protection properties
            this.setProtectionProperties(
              doc,
              protection,
              is_fixing_element,
              coveringEle,
              typecode
            );
            this.InsertPartZoneProperties(
              harness3dDesignSolution,
              pz,
              doc,
              protection
            );

            if (covering_consistent) {
              if (protection1 != null) {
                harness.appendChild(protection1);
              }
              harness.appendChild(protection);
              console.log(
                covering_string +
                  " created : " +
                  protectionDisName +
                  " id :" +
                  coveringEle.id
              );
            } else {
              console.log(
                "ERROR: " +
                  covering_string +
                  " NOT created : " +
                  protectionDisName +
                  " id :" +
                  coveringEle.id
              );
            }
          }
        }
      }
    }
    // functionality to checkMerge protections
    if (insulExists && this.option_merge_protections) this.checkMerge(harness);
  }
  //method to compute offsetparameters for bundle location
  getOffSets(bundleLoc1: any, bundleLoc2: any): any {
    let offset1;
    let offset2;
    let tempOff1 = bundleLoc1.getAttribute("offsetparameter"); //start
    let tempOff2 = bundleLoc2.getAttribute("offsetparameter"); //end
    if (bundleLoc1.getAttribute("offsetnoderef") === "end") {
      tempOff1 = 1 - tempOff1;
    }
    if (bundleLoc2.getAttribute("offsetnoderef") === "end") {
      tempOff2 = 1 - tempOff2;
    }
    if (tempOff1 < tempOff2) {
      offset1 = tempOff1;
      offset2 = tempOff2;
    } else {
      offset1 = tempOff2;
      offset2 = tempOff1;
    }

    return {
      offset1,
      offset2,
    };
  }
  //method to compute merge object to filter protection merge
  computeMergeProt(protObj: any): any {
    let protectionSafe: string[] = [];
    // to handle multiple mergeConditions
    // mergeIndex to log multiple protections satisfying protection_safe protocols
    // prev_bundle to increment mergeIndex only when new bundle is encountered thus populating merge{}
    let mergeIndex = 0;
    const merge: { [key: number]: any } = {};
    let prevBundle = "";
    for (const key in protObj) {
      const proID = protObj[key];
      for (const key1 in protObj) {
        const proID1 = protObj[key1];
        if (key != key1) {
          // only when bundleref,PNs,diameter are same--satisfies merge_condn
          if (
            proID.bundle === proID1.bundle &&
            proID.partNumber === proID1.partNumber &&
            proID.diameter === proID1.diameter
          ) {
            if (mergeIndex === 0) {
              mergeIndex++;
            }
            // if new bundle is encountered
            else if (prevBundle != proID.bundle) {
              protectionSafe = [];
              mergeIndex++;
            }
            // storing each new bundle
            prevBundle = proID.bundle;
            if (!protectionSafe.includes(key)) {
              merge[mergeIndex] = protectionSafe;
              protectionSafe.push(key);
            }
            if (!protectionSafe.includes(key1)) {
              merge[mergeIndex] = protectionSafe;
              protectionSafe.push(key1);
            }
          }
        }
      }
    }
    return merge;
  }
  //post filtering on routes - only elements related to input routes should be in downloaded xml file
  public async filterOnRoutes(
    harness: any,
    wiringconnectivity: any,
    bundleObj: object
  ): Promise<any> {
    //bundleObj consist of key as bundleId which is related to inputroutes and value as array of startnode and endnode of particular bundle
    try {
      //Data to store details of tags to be fitered based on search routes
      const data: Array<object> = [
        { tag: "node", attribute: "id" },
        { tag: "connector", attribute: "nodeid" },
        {
          tag: "insulationRun",
          innerTag: "startLocation",
          attribute: "bundleRef",
        },
        { tag: "fixing", innerTag: "Location", attribute: "bundleRef" },
        { tag: "bundle", attribute: "id" },
        {
          tag: "protection",
          innerTag: "startLocation",
          attribute: "insulationrun",
          innerAttribute: "bundleRef",
        },
      ];
      //insulationIdArray to store insulationId linked with insulationRun which is to be deleted
      const insulationIdArray: string[] = [];
      let check = false;
      return await Promise.all(
        data.map((file: any) => {
          const xmlElem =
            file.tag == "connector" ? wiringconnectivity : harness;
          const xmlFile = xmlElem.getElementsByTagName(file.tag);
          if (xmlFile) {
            let rmXml: boolean;
            //Iterating the xml tags
            for (let i = 0; i < xmlFile.length; i++) {
              rmXml = false; // flag to mark the tag which will be filtered out from the xml
              let attrLoc = xmlFile[i];
              if (file.innerTag) {
                const location = xmlFile[i].getElementsByTagName(file.innerTag);
                //check for checking inner tag of protection is available or not
                check = location[0] && file.tag == "protection" ? true : false;
                attrLoc = location[0] ? location[0] : attrLoc;
              }
              const attr = check
                ? attrLoc.getAttribute(file.innerAttribute)
                : attrLoc.getAttribute(file.attribute);
              //Filtering the protection tag linked with insulationRun
              if (!check && file.tag == "protection") {
                // Checking condition if insulation is attribute of protection if so then check in array if id matches delete that protection
                rmXml = insulationIdArray.some((elem) => elem == attr)
                  ? true
                  : rmXml;
              }
              //Filtering the tags linked with nodeid
              else if (file.tag == "node" || file.tag == "connector") {
                let flag = false;
                //checking if nodeId matches with startnode and endnode
                for (const value of Object.values(bundleObj)) {
                  flag = attr == value[0] || attr == value[1] ? true : flag;
                }
                //If none of id matches the tag
                rmXml = !flag ? true : rmXml;
              }
              //Filtering the tags linked with bundle
              else if (!(attr in bundleObj)) {
                rmXml = true;
                if (file.tag == "insulationRun")
                  insulationIdArray.push(xmlFile[i].getAttribute("id"));
              }
              //Removing the filtered tag from xml file
              if (rmXml) {
                xmlElem.removeChild(xmlFile[i]);
                i--;
              }
            }
          }
          return Promise.resolve();
        })
      );
    } catch (error) {
      console.log("Error in post filtering on routes :", error);
      return Promise.reject(error);
    }
  }

  // functionality to checkMergeProtections
  public checkMerge(harness: any) {
    // creation of object:protection
    // prot_obj stores info wrt protectionID
    // prot_obj:created only for those protections whose bundles are same i.e., covering only one branch
    const protObj: { [key: string]: any } = {};
    const insulationRun = harness.getElementsByTagName("insulationRun");
    if (insulationRun) {
      for (let i = 0; i < insulationRun.length; i++) {
        const startLocation =
          insulationRun[i].getElementsByTagName("startLocation");
        const bundleLoc1 =
          startLocation[0].getElementsByTagName("bundleLocation");
        const endLocation =
          insulationRun[i].getElementsByTagName("endLocation");
        const bundleLoc2 =
          endLocation[0].getElementsByTagName("bundleLocation");
        // storing only when bundleRef is same
        if (
          endLocation[0].getAttribute("bundleRef") ===
          startLocation[0].getAttribute("bundleRef")
        ) {
          const key = insulationRun[i].getAttribute("id");
          const offsets = this.getOffSets(bundleLoc1[0], bundleLoc2[0]);
          protObj[endLocation[0].getAttribute("id").split(".")[0]] = {
            insulationID: key,
            bundle: endLocation[0].getAttribute("bundleRef"),
            offset1: offsets.offset1,
            offset2: offsets.offset2,
          };
        }
      }

      // fetching respective protections info
      const protectionXml = harness.getElementsByTagName("protection");
      for (let i = 0; i < protectionXml.length; i++) {
        for (const key in protObj) {
          // considering only those ID's wrt entries in prot_obj{}
          const pID = protObj[key];
          if (key === protectionXml[i].getAttribute("id")) {
            pID.pName = protectionXml[i].getAttribute("name");
            pID.partNumber = protectionXml[i].getAttribute("partnumber");
            pID.diameter = protectionXml[i].getAttribute("innerDiameter");
            pID.length = protectionXml[i].getAttribute("length");
          }
        }
      }
      //logging prot_obj
      /*example: protection2: {
      insulationID: 'insulationRun1',
      bundle: 'bundle1',
      offset1: '0',
      offset2: 1,
      pName: 'E9293123120000_R3-BRA0001-EN6049-006----5.7',
      partNumber: 'EN6049-006----5',
      diameter: '0.0125',     
      length: '0.07'
      }**/
      console.log("prot object", protObj);
      // protection_safe considers to populate mergeIDs with safe protection(prot satifying merge conditions)
      // whose bundleref,PNs,diameters are same thus validating most merge conditions
      // to handle multiple mergeConditions
      // mergeIndex to log multiple protections satisfying protection_safe protocols
      // prev_bundle to increment mergeIndex only when new bundle is encountered thus populating merge{}
      const merge: { [key: number]: any } = this.computeMergeProt(protObj);
      // ex-merge{{ '1': [ 'protection4', 'protection7', 'protection8' ] }}
      // above object is created to have only those protections under mergeIDs whose pns,bundle,diameter same
      // logging the info
      /* example: grouping safe_protections under same ID to merge(if contiguous)
        1:['protection2','protection3']
      */
      console.log(merge);
      //then once we satisfy 1st three conditions we check if the offset are contiguous

      // considering each MergeID and then checkSort()
      // checkSort() sorts each MergeIDs protections based on offset1,offset2
      // after sort checks if protections satisfying protection_Safe protocols are contiguos or not
      // if any protection is not contiguos then that entry is removed and for rest the protections are modified
      for (const key in merge) {
        this.checkSort(
          merge[key],
          protObj,
          harness,
          protectionXml,
          insulationRun
        );
      }
    }
  }
  // function to sort protections based on offset and check continuity
  public checkSort(
    protections: any,
    protObj: { [key: string]: any },
    harness: any,
    protectionXml: any,
    insulationRun: any
  ) {
    let sortable = []; // sortable to sort protections
    for (const key of protections) {
      // sort based on offset1
      sortable.push([key, protObj[key].offset1, protObj[key].offset2]);
    }
    sortable.sort(function (a, b) {
      return a[1] - b[1];
    });
    // have to check contiguous in order to merge proper protections
    for (let i = 0; i < sortable.length; i++) {
      const protID = sortable[i];
      if (i + 1 < sortable.length) {
        const protID1 = sortable[i + 1];
        if (protID1[1] - protID[2] > 1e-3) {
          // if under same mergeID some are not contiguous we slice them and merge only those protections which are contiguous
          const temp_sort = sortable.slice(0, i + 1);
          if (temp_sort.length > 1)
            this.modify_merge(
              protObj,
              harness,
              protectionXml,
              insulationRun,
              temp_sort
            );
          sortable = sortable.slice(i + 1);
        }
      }
    }
    // at any situation if we find contiguous is false then the index is tracked
    // rest protections after that index are sliced
    // this is to ensure only contiguous protections are merged rest are not considered
    console.log(sortable);
    /* ex: sortable[
      [ 'protection4', '0.09712772929367224', 0.9528517612224595 ],
      [ 'protection3', '0.9528517612224595', '1' ]
    ]*/
    if (sortable.length > 1)
      this.modify_merge(
        protObj,
        harness,
        protectionXml,
        insulationRun,
        sortable
      );
  }
  // method to filterProtections which aren't mergable
  removeProtections(
    sortable: any,
    harness: any,
    protectionXml: any,
    protObj: any
  ) {
    const finalInsul = []; // to remove concerned insulationIDs
    for (let i = 1; i < sortable.length; i++) {
      const prot_id = sortable[i];
      let prot_xml = null;
      for (let j = 0; j < protectionXml.length; j++) {
        if (protectionXml[j].getAttribute("id") === prot_id[0]) {
          finalInsul.push(protObj[prot_id[0]].insulationID);
          prot_xml = protectionXml[j];
          harness.removeChild(prot_xml);
          break;
        }
      }
    }
    return finalInsul;
  }
  //remove respective insulationRuns to support mergeProtections
  removeInsulationRuns(finalInsul: any, harness: any, insulationRun: any) {
    for (let i = 0; i < finalInsul.length; i++) {
      const insul_id = finalInsul[i];
      let insulXml = null;
      for (let j = 0; j < insulationRun.length; j++) {
        if (insulationRun[j].getAttribute("id") === insul_id) {
          insulXml = insulationRun[j];
          harness.removeChild(insulXml);
          break;
        }
      }
    }
  }
  //method to modify right protections which are mergable
  modifyProtection(protectionXml: any, sortable: any, protObj: any) {
    let prot_name = protObj[sortable[0][0]].pName + "_";
    let prot_disp_name = "";
    let prot_length = Number(protObj[sortable[0][0]].length);
    for (let i = 0; i < protectionXml.length; i++) {
      if (protectionXml[i].getAttribute("id") === sortable[0][0]) {
        for (let j = 1; j < sortable.length; j++) {
          if (j === sortable.length - 1) {
            const prot_id = protObj[sortable[j][0]].pName;
            prot_name =
              prot_name +
              protObj[sortable[j][0]].pName.substr(
                prot_id.lastIndexOf("-") + 1
              );
          } else {
            const prot_id = protObj[sortable[j][0]].pName;
            prot_name =
              prot_name +
              protObj[sortable[j][0]].pName.substr(
                prot_id.lastIndexOf("-") + 1
              ) +
              "_";
          }
          prot_length = prot_length + Number(protObj[sortable[j][0]].length);
          prot_length = Number(prot_length.toFixed(3));
        }
        protectionXml[i].setAttribute("name", prot_name);
        const pos = prot_name.indexOf("_");
        prot_disp_name = prot_name.slice(pos + 1);
        protectionXml[i].setAttribute("displayName", prot_disp_name);
        protectionXml[i].setAttribute("length", prot_length);
        break;
      }
    }
    return {
      prot_name,
      prot_disp_name,
      prot_length,
    };
  }
  //modifying insulationRun after merging
  modifyInsulationRun(
    insulationRun: any,
    modifiedValues: any,
    sortable: any,
    protObj: any
  ) {
    const insul_name = "RUN_" + modifiedValues.prot_name;
    const insul_disp_name = "RUN_" + modifiedValues.prot_disp_name;
    const insul_length = modifiedValues.prot_length * 1000;
    for (let i = 0; i < insulationRun.length; i++) {
      if (
        insulationRun[i].getAttribute("id") ===
        protObj[sortable[0][0]].insulationID
      ) {
        insulationRun[i].setAttribute("name", insul_name);
        insulationRun[i].setAttribute("displayName", insul_disp_name);
        const startLocation =
          insulationRun[i].getElementsByTagName("startLocation");
        const bundleLoc1 =
          startLocation[0].getElementsByTagName("bundleLocation");
        bundleLoc1[0].setAttribute("offsetparameter", sortable[0][1]);
        bundleLoc1[0].setAttribute("offsetnoderef", "start");
        const endLocation =
          insulationRun[i].getElementsByTagName("endLocation");
        const bundleLoc2 =
          endLocation[0].getElementsByTagName("bundleLocation");
        bundleLoc2[0].setAttribute(
          "offsetparameter",
          sortable[sortable.length - 1][2]
        );
        bundleLoc2[0].setAttribute("offsetnoderef", "start");
        const property_length =
          insulationRun[i].getElementsByTagName("property");
        property_length[3].setAttribute("name", "LENGTH");
        property_length[3].setAttribute("val", insul_length);
        break;
      }
    }
  }
  // modify prot&insul if satisfied checkSort()
  public modify_merge(
    protObj: { [key: string]: any },
    harness: any,
    protectionXml: any,
    insulationRun: any,
    sortable: any
  ) {
    // first removal of protections
    //this.removeProtections(sortable,harness,protectionXml,protObj);
    const finalInsul = this.removeProtections(
      sortable,
      harness,
      protectionXml,
      protObj
    );
    // remove concerned insulationRUns
    this.removeInsulationRuns(finalInsul, harness, insulationRun);
    // modify existing protection first
    const modifiedValues = this.modifyProtection(
      protectionXml,
      sortable,
      protObj
    );
    //modify existing insulationRun
    this.modifyInsulationRun(insulationRun, modifiedValues, sortable, protObj);
  }

  // forming the extremity name
  private getExtremityName(
    b3dExtCovrngEleLength: number,
    bundleRef: Pedge,
    ext_name: string
  ): string {
    const b3dExtCovrngEleLengthmm = b3dExtCovrngEleLength.toFixed();
    ext_name += "-L" + b3dExtCovrngEleLengthmm;
    const b3dExtCovrngEleLengthM = b3dExtCovrngEleLength / 1000;
    const length_percent = b3dExtCovrngEleLengthM / bundleRef.length;
    if (length_percent < 1e-3) ext_name = bundleRef.node1.name;
    else if (length_percent > 0.999) ext_name = bundleRef.node2.name;
    return ext_name;
  }

  // check if protectionbranch ext1 is corresponding to the reference extremity
  private findProtBranchRefExtremity(
    bundleRef: Pedge,
    search_extid: number,
    branchFound: boolean,
    branchExtNumber: number,
    extremityName: string
  ): any[] {
    let branch_found = branchFound;
    let ext_name = extremityName;
    let branch_ext_number = branchExtNumber;
    if (
      bundleRef.node1.db_id == search_extid ||
      bundleRef.node1.db_id2 == search_extid
    ) {
      branch_found = true;
      branch_ext_number = 1;
      ext_name += "-" + bundleRef.node1.name;
    } else if (
      bundleRef.node2.db_id == search_extid ||
      bundleRef.node2.db_id2 == search_extid
    ) {
      branch_found = true;
      branch_ext_number = 2;
      ext_name += "-" + bundleRef.node2.name;
    }

    return [branch_found, ext_name, branch_ext_number];
  }

  // finding the covering extremities
  private findCoveringExtremities(
    coveringEle: CoveringElement3d,
    myGraph: Graph,
    tab_bundleRef: Pedge[],
    tab_ext_name: string[],
    tab_ext_number: number[]
  ): void {
    let branch_ext_number = 0;
    coveringEle.b3dExt.forEach((b3dExtCovrngEle) => {
      const search_extid = b3dExtCovrngEle.branch3dExtremityId;
      let branch_found = false;
      // find all the prot_branches related to the protection
      if (coveringEle.branch != null) {
        coveringEle.branch.forEach((protectb3d) => {
          let ext_name = "";
          // retrieve the edge in the graph for the prot_branch related to the protection
          const bundleRef = myGraph.edges.find(
            (edge) => edge.db_id === protectb3d.id
          );
          if (!branch_found && bundleRef != null) {
            ext_name += bundleRef.name;
            // check if prot_branch ext1 is corresponding to the reference extremity
            const branchExtDetails = this.findProtBranchRefExtremity(
              bundleRef,
              search_extid,
              branch_found,
              branch_ext_number,
              ext_name
            );
            branch_found = branchExtDetails[0];
            ext_name = branchExtDetails[1];
            branch_ext_number = branchExtDetails[2];
            // we find the branch linked to the protection extremity
            if (branch_found) {
              tab_bundleRef.push(bundleRef);
              const b3dExtCovrngEleLength = b3dExtCovrngEle.lengthMm;
              if (b3dExtCovrngEleLength != null) {
                ext_name = this.getExtremityName(
                  b3dExtCovrngEleLength,
                  bundleRef,
                  ext_name
                );
              }
              tab_ext_name.push(ext_name);
              tab_ext_number.push(branch_ext_number);
            }
          }
        });
      }
    });
  }

  // finding the Extremities
  private findExtremities(
    tab_ext_name: string[],
    isFixingElem: boolean,
    tab_tag_name: string[]
  ): void {
    // case only one protection extremity
    if (tab_ext_name.length == 1) {
      if (isFixingElem) {
        tab_tag_name[0] = "Location";
      } else {
        tab_tag_name[0] = "startLocation";
      }
    }
    // case 2 protection extremities: we order the extremities acccording to the ext name in ascii order
    else if (tab_ext_name.length == 2) {
      if (tab_ext_name[0] > tab_ext_name[1]) {
        tab_tag_name[0] = "endLocation";
        tab_tag_name[1] = "startLocation";
      } else {
        tab_tag_name[0] = "startLocation";
        tab_tag_name[1] = "endLocation";
      }
    }
  }

  // creating the tag
  private tagCreation(
    coveringEle: CoveringElement3d,
    doc: any,
    covering_string: string,
    protectionIndex: number,
    protection: any,
    exts_created: number[],
    ...otherParams: any
  ): number[] {
    const tab_tag_name: string[] = otherParams[0];
    const tab_bundleRef: Pedge[] = otherParams[1];
    const tab_ext_name: string[] = otherParams[2];
    const tab_ext_number: number[] = otherParams[3];
    let i = 0;
    coveringEle.b3dExt.forEach((b3dExtCovrngEle2) => {
      if (i < tab_tag_name.length) {
        const bundleRef = tab_bundleRef[i];
        const ext_name = tab_ext_name[i];
        const branch_ext_number = tab_ext_number[i];
        const tag_name = tab_tag_name[i];
        i += 1;
        const Location = doc.createElement(tag_name);
        Location.setAttribute(
          "id",
          covering_string + protectionIndex + "." + tag_name
        );
        // force the displayName of the protection point when it is in the middle of the branch
        const b3dExtCovrngEleLengthM = b3dExtCovrngEle2.lengthMm / 1000;
        let length_percent = b3dExtCovrngEleLengthM / bundleRef.length;
        if (length_percent > 1e-3 && length_percent < 0.999)
          Location.setAttribute("displayName", ext_name);
        Location.setAttribute("bundleRef", "bundle" + bundleRef.number);
        const bundleLocation = doc.createElement("bundleLocation");
        if (length_percent > 1) {
          console.log(
            "ERROR on protection point: ",
            ext_name,
            " length percent = ",
            length_percent,
            " is greater than 1"
          );
          console.log(
            "length_percent is forced to 0.999 in order to allow import"
          );
          length_percent = 0.999;
        }
        bundleLocation.setAttribute("offsetparameter", length_percent);
        // depending on the extremity number we give start or end attribute
        let absolute_length_percent = -1;
        if (branch_ext_number == 1) {
          bundleLocation.setAttribute("offsetnoderef", "start");
          absolute_length_percent = length_percent;
        } else if (branch_ext_number == 2) {
          bundleLocation.setAttribute("offsetnoderef", "end");
          absolute_length_percent = 1 - length_percent;
        }
        if (absolute_length_percent >= 0 && absolute_length_percent <= 1)
          exts_created.push(absolute_length_percent);
        Location.appendChild(bundleLocation);
        protection.appendChild(Location);
      }
    });
    return exts_created;
  }

  // checking the extermities & setting coveringConsistent
  private checkingExtremities(
    exts_created: number[],
    tab_bundleRef: Pedge[],
    covering_consistent: boolean
  ): boolean {
    let coveringConsistent = covering_consistent;
    if (
      exts_created[0] >= 0 &&
      exts_created[0] <= 1 &&
      exts_created[1] >= 0 &&
      exts_created[1] <= 1
    ) {
      // if 2 extremities are on the same bundle they should not be coincident
      if (tab_bundleRef[0].number == tab_bundleRef[1].number) {
        if (Math.abs(exts_created[0] - exts_created[1]) > 1e-3) {
          coveringConsistent = true;
        }
      } else {
        coveringConsistent = true;
      }
    }
    return coveringConsistent;
  }

  // Check protection consistency for sleeve with 2 distincts extremities required
  private findingConsistency(
    coveringEle: CoveringElement3d,
    exts_created: number[],
    tab_bundleRef: Pedge[]
  ): boolean {
    let covering_consistent = false;
    if (
      coveringEle.cvrgElemType.name == "SLEEVE" ||
      coveringEle.cvrgElemType.name == "LACING_TAPE"
    ) {
      // for a sleeve 2 extremities required
      if (exts_created.length == 2) {
        // ratios should be between 0 and 1
        covering_consistent = this.checkingExtremities(
          exts_created,
          tab_bundleRef,
          covering_consistent
        );
      }
    }
    // for other cases only one extremity is expected
    else {
      if (exts_created.length == 1) {
        if (exts_created[0] >= 0 && exts_created[0] <= 1) {
          covering_consistent = true;
        }
      }
    }
    return covering_consistent;
  }

  // method dedicated to create the PROTECTIONs & MARKERs START and END nodes
  public createProtectionHX2MLExtremities(
    doc: any,
    protection: any,
    protectionIndex: number,
    coveringEle: CoveringElement3d,
    isFixingElem: boolean,
    myGraph: Graph
  ) {
    let covering_string = "";
    if (isFixingElem) {
      covering_string = "fixing";
    } else {
      covering_string = "protection";
    }
    const exts_created: number[] = [];
    const tab_bundleRef: Pedge[] = [];
    const tab_ext_name: string[] = [];
    const tab_ext_number: number[] = [];
    const tab_tag_name: string[] = [];
    // the goal is to find the ref extremities, the related branches and the length of the start and end protection points
    // from the ref extremities.
    // retrieve the 2 references extremities defining the covering element
    // loop on each covering extremities
    this.findCoveringExtremities(
      coveringEle,
      myGraph,
      tab_bundleRef,
      tab_ext_name,
      tab_ext_number
    );
    this.findExtremities(tab_ext_name, isFixingElem, tab_tag_name);
    // second loop on each covering extremities to create the tags
    this.tagCreation(
      coveringEle,
      doc,
      covering_string,
      protectionIndex,
      protection,
      exts_created,
      tab_tag_name,
      tab_bundleRef,
      tab_ext_name,
      tab_ext_number
    );

    // Check protection consistency for sleeve with 2 distincts extremities required
    return this.findingConsistency(coveringEle, exts_created, tab_bundleRef);
  }

  // compare 2 routes according to their name
  compareRoutes(route1: RouteCategoryModel, route2: RouteCategoryModel) {
    if (route1.name > route2.name) {
      return 1;
    } else if (route1.name < route2.name) {
      return -1;
    }
    return 0;
  }

  public eucDistance(pointA: number[], pointB: number[]) {
    return (
      pointA
        .map((x, i) => Math.abs(x - pointB[i]) ** 2) // square the difference
        .reduce((sum, now) => sum + now) ** // sum
      (1 / 2)
    );
  }

  // create the waypoints & segments of the graph
  private prepareSegment(
    waypoint1: Pwaypoint,
    waypoint2: Pwaypoint,
    segment: any,
    i: number,
    waypointsLength: number
  ): void {
    const length = this.eucDistance(
      [waypoint1.positionX, waypoint1.positionY, waypoint1.positionZ],
      [waypoint2.positionX, waypoint2.positionY, waypoint2.positionZ]
    );
    segment.setAttribute("type", "bend");
    segment.setAttribute("length", length);
    if (i === 0) {
      segment.setAttribute("start", "start");
    } else {
      segment.setAttribute("start", waypoint1.id);
    }
    if (i === waypointsLength - 2) {
      segment.setAttribute("end", "end");
    } else {
      segment.setAttribute("end", waypoint2.id);
    }
  }

  // Only for GEOMETRY: Method to create the REFINED discretisation segments
  public createSegmentsHX2MLfile(
    doc: any,
    segments: any,
    b3d: Branch3DModel,
    waypoints: Pwaypoint[]
  ) {
    // Add segment details only if branch point definition exists for branch.
    if (b3d.b3dpointDef) {
      const waypointsLength = waypoints.length;
      for (let i = 0; i < waypointsLength - 1; i++) {
        const segment = doc.createElement("segment");
        const waypoint1 = waypoints[i];
        const waypoint2 = waypoints[i + 1];

        if (waypoint1 && waypoint2) {
          // create the waypoints of the graph
          this.prepareSegment(
            waypoint1,
            waypoint2,
            segment,
            i,
            waypointsLength
          );
        } else {
          console.log("Waypoint not found for segment");
        }
        segments.appendChild(segment);
      }
    }
  }

  // calculates the coordinates
  private getCoordinates(b3dPointDef: any) {
    return {
      positionX: b3dPointDef.coordinateX / 1000,
      positionY: b3dPointDef.coordinateY / 1000,
      positionZ: b3dPointDef.coordinateZ / 1000,
    };
  }

  // preparing & setting the directions
  private prepareDirection(
    doc: any,
    vector_x_m: any,
    vector_y_m: any,
    vector_z_m: any
  ): any {
    const direction = doc.createElement("Direction");
    direction.setAttribute("x", vector_x_m);
    direction.setAttribute("y", vector_y_m);
    direction.setAttribute("z", vector_z_m);
    return direction;
  }

  // preparing my way point
  private prepareMyWayPoint(
    id: number,
    b3dPointDef: BranchPointDefinitionModel,
    vector_x_m: any,
    vector_y_m: any,
    vector_z_m: any
  ): Pwaypoint {
    return {
      id: id,
      db_id: b3dPointDef.id,
      ...this.getCoordinates(b3dPointDef),
      directionX: vector_x_m,
      directionY: vector_y_m,
      directionZ: vector_z_m,
    };
  }

  // preparing & setting way point
  private prepareWayPoint(
    b3d: Branch3DModel,
    doc: any,
    segments: any,
    my_waypoints: Pwaypoint[],
    nb_points: number
  ) {
    let i = 0;
    b3d.b3dpointDef.forEach((b3dPointDef: BranchPointDefinitionModel) => {
      i += 1;
      if (i == 1 || i == nb_points) {
        const waypoint = doc.createElement("waypoint");
        if (i == 1) {
          waypoint.setAttribute("id", "start");
        } else {
          waypoint.setAttribute("id", "end");
        }
        const vector_x_m = b3dPointDef.vectorX;
        const vector_y_m = b3dPointDef.vectorY;
        const vector_z_m = b3dPointDef.vectorZ;
        const direction = this.prepareDirection(
          doc,
          vector_x_m,
          vector_y_m,
          vector_z_m
        );
        const my_waypoint = this.prepareMyWayPoint(
          i,
          b3dPointDef,
          vector_x_m,
          vector_y_m,
          vector_z_m
        );

        my_waypoints.push(my_waypoint);

        waypoint.appendChild(direction);
        segments.appendChild(waypoint);
      } else {
        const waypoint = doc.createElement("waypoint");
        waypoint.setAttribute("id", i);
        const position = doc.createElement("Position");
        const { positionX, positionY, positionZ } =
          this.getCoordinates(b3dPointDef);
        position.setAttribute("x", positionX);
        position.setAttribute("y", positionY);
        position.setAttribute("z", positionZ);

        const vector_x_m = b3dPointDef.vectorX;
        const vector_y_m = b3dPointDef.vectorY;
        const vector_z_m = b3dPointDef.vectorZ;

        const direction = this.prepareDirection(
          doc,
          vector_x_m,
          vector_y_m,
          vector_z_m
        );
        const my_waypoint = this.prepareMyWayPoint(
          i,
          b3dPointDef,
          vector_x_m,
          vector_y_m,
          vector_z_m
        );

        my_waypoints.push(my_waypoint);

        waypoint.appendChild(position);
        waypoint.appendChild(direction);
        segments.appendChild(waypoint);
      }
    });
  }

  // supressing the Mid Point
  private supressMidPoint(b3d: Branch3DModel) {
    let middle_point_index = -1;
    let it = 0;
    b3d.b3dpointDef.forEach((b3dPointDef) => {
      if (b3dPointDef.middle) {
        middle_point_index = it;
      }
      it += 1;
    });
    if (middle_point_index >= 0) {
      b3d.b3dpointDef.splice(middle_point_index, 1);
    }
  }

  // deciding the first & last points based on length
  private decidePointsBasedOnLength(
    myGraph: Graph,
    b3d: Branch3DModel,
    x: any,
    y: any,
    z: any
  ): any {
    let first_point_ok = false;
    let last_point_ok = false;
    // retrieve the edge in the graph for the prot_branch related to the protection
    const bundleRef = myGraph.edges.find((edge) => edge.db_id === b3d.id);
    if (bundleRef) {
      const length1 = this.eucDistance(
        [x, y, z],
        [bundleRef.node1.x, bundleRef.node1.y, bundleRef.node1.z]
      );
      if (length1 < 1e-3) {
        first_point_ok = true;
      } else {
        const length2 = this.eucDistance(
          [x, y, z],
          [bundleRef.node2.x, bundleRef.node2.y, bundleRef.node2.z]
        );
        if (length2 < 1e-3) {
          last_point_ok = true;
        }
      }
    }

    return { first_point_ok, last_point_ok };
  }

  // Only for GEOMETRY: method dedicated to create the REFINED Segments of bundles  in the HX2ML file (from the CoreElec branches)
  public createBundleSegmentsHX2MLfile(
    doc: any,
    b3d: Branch3DModel,
    myGraph: Graph
  ) {
    const segments = doc.createElement("segments");
    const my_waypoints: Pwaypoint[] = [];
    // Add segment details only if branch point definition exists for branch.
    // for the moment we de activate the code as the branch extremities are not corresponding to the start and end (can be inverted)
    if (b3d.b3dpointDef && b3d.b3dpointDef.length) {
      this.supressMidPoint(b3d);
      const nb_points = b3d.b3dpointDef.length;
      if (!nb_points) return null;

      // check if branch node1 correspond to the first or last point
      const first_point = b3d.b3dpointDef[0];
      const x = first_point.coordinateX;
      const y = first_point.coordinateY;
      const z = first_point.coordinateZ;
      const { first_point_ok, last_point_ok } = this.decidePointsBasedOnLength(
        myGraph,
        b3d,
        x,
        y,
        z
      );

      // invert if first point of branch is the last point of the branch def
      if (last_point_ok) b3d.b3dpointDef.reverse();
      if (first_point_ok || last_point_ok) {
        this.prepareWayPoint(b3d, doc, segments, my_waypoints, nb_points);
      }
    } else {
      console.log(
        "Branch 3D Point Definition does not exists for branch " + b3d.id
      );
    }
    this.createSegmentsHX2MLfile(doc, segments, b3d, my_waypoints);
    return segments;
  }
  //Gets extremities of nodes of branch
  public getNodeExtremity(
    myGraph: Graph,
    b3dExt: Branch3dExtremitySolutionModel
  ): Pnode {
    let my_node = myGraph.nodes.find((node) => node.db_id === b3dExt.id);
    if (my_node == null) {
      my_node = myGraph.nodes.find((node) => node.db_id2 === b3dExt.id);
    }
    return my_node;
  }
  //create and store edges in graph for bundle
  public createEdges(
    my_node1: Pnode,
    my_node2: Pnode,
    b3d: Branch3DModel,
    bundle: any,
    bundleIndex: number,
    bundleDisName: string
  ): Pedge {
    let my_node1_s = my_node1;
    let my_node2_s = my_node2;

    if (my_node1.name > my_node2.name) {
      my_node1_s = my_node2;
      my_node2_s = my_node1;
    }
    const my_edge = new Pedge(my_node1_s, my_node2_s);

    my_edge.db_id = b3d.id;
    my_edge.number = bundleIndex;
    my_edge.name = bundleDisName;
    my_edge.length = 0;

    // create start and endNodes attributes
    bundle.setAttribute("startNode", "node" + my_node1_s.number);
    bundle.setAttribute("endNode", "node" + my_node2_s.number);

    // creating length and diameter attributes of the bundle

    const length_mm = b3d.lengthMm;
    const forcedLength_mm = b3d.lengthForcedMm;

    my_edge.forced_length = this.convertForcedLength(forcedLength_mm, my_edge);

    // converting length mm to m
    my_edge.length = length_mm / 1000;

    if (my_edge.forced_length > 0) {
      bundle.setAttribute("length", my_edge.forced_length.toPrecision(5));
    } else {
      bundle.setAttribute("length", my_edge.length.toPrecision(5));
    }

    return my_edge;
  }
  //gets the bundle property CATIA Segments
  public getCatiaSegments(b3d: Branch3DModel): string {
    let catia_segments = "";
    b3d.segments.forEach((segment) => {
      console.log("Bundle segment : " + segment.name);
      if (catia_segments != "") catia_segments += ", ";
      catia_segments += segment.name;
    });
    return catia_segments;
  }

  // method dedicated to create the BUNDLES of GRAPH  in the HX2ML file (from the CoreElec branches)
  public createBundlesHX2MLfile(
    doc: any,
    harness: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[],
    myGraph: Graph,
    inputRoute: string[]
  ) {
    let bundleIndex = 1;
    const bundleObj: { [key: string]: string[] } = {};
    // scan all partzones of DS
    MyPartZones.forEach((pz) => {
      // scan all branches related to partzone
      pz.b3d.forEach((b3d) => {
        if (this.isBranchValid(b3d, pz) === true) {
          const bundle = doc.createElement("bundle");

          let bundleDisName = pz.userArea.name + "-";
          bundleDisName = bundleDisName + b3d.name;
          bundle.setAttribute(
            "name",
            harness3dDesignSolution.adapDesignSolutionNumber +
              "_" +
              bundleDisName
          );
          bundle.setAttribute("displayName", bundleDisName);
          bundle.setAttribute("id", "bundle" + bundleIndex);

          // searching for the nodes in the graph corresponding to the extremities of the bundle
          let i = 0;
          let my_node1: Pnode;
          let my_node2: Pnode;

          // search for 2 branch extremities and retrieve the node number

          b3d.b3dExt.forEach((b3dExt) => {
            // myGraph.nodes
            //get Node Extremities for Both nodes of a branch. N1 and N2
            i += 1;
            if (i == 1) {
              my_node1 = this.getNodeExtremity(myGraph, b3dExt);
            } else if (i == 2) {
              my_node2 = this.getNodeExtremity(myGraph, b3dExt);
            }
          });

          //checks if either node extremities is null
          const nodes_exist: boolean = this.checkNodeExtremities(
            my_node1,
            my_node2
          );
          if (nodes_exist) {
            // create the edges of the graph (one edge for one bundle)
            // store the end points in alphabetic order

            const my_edge = this.createEdges(
              my_node1,
              my_node2,
              b3d,
              bundle,
              bundleIndex,
              bundleDisName
            );

            myGraph.addEdge(my_edge);

            // converting diameter & bendRadius mm to m
            const bundleDiameter = b3d.diameter3dMm / 1000;
            const bendRadius = b3d.bendRadius / 1000;
            bundle.setAttribute(
              "bundleDiameter",
              bundleDiameter.toPrecision(5)
            );
            bundle.setAttribute("maxDiameter", bundleDiameter.toPrecision(5));
            bundle.setAttribute("bendRadius", bendRadius.toPrecision(5));
            // If branch point is set true the segment tag is activated
            let segments: object = {};
            if (this.option_branch_point) {
              segments = this.createBundleSegmentsHX2MLfile(doc, b3d, myGraph);
            }

            // Add PART property
            this.createProperty("CATIA_TYPE", "PART", bundle, doc);
            // Add Not Extractible property
            this.createProperty(
              "NOT_EXTRACTIBLE",
              b3d.notExtractible,
              bundle,
              doc
            );
            // Add Routes property and sort the effective routes
            let routeName = "";
            let route_index = 0;
            let my_node1_s = my_node1;
            let my_node2_s = my_node2;

            if (my_node1.name > my_node2.name) {
              my_node1_s = my_node2;
              my_node2_s = my_node1;
            }
            // sorting the effective routes
            b3d.effectiveRoutes.sort(this.compareRoutes);
            b3d.effectiveRoutes.forEach((route) => {
              route_index++;
              if (route_index == 1) {
                routeName = route.name;
              } else if (route_index > 1) {
                routeName = routeName + "," + route.name;
              }
              //creation of bundleObj by checking condition of inputRoutes
              console.log(inputRoute);
              if (inputRoute && inputRoute.length) {
                for (let j = 0; j < inputRoute.length; j++) {
                  if (inputRoute[j] == route.name) {
                    bundleObj["bundle" + bundleIndex] = [
                      "node" + my_node1_s.number,
                      "node" + my_node2_s.number,
                    ];
                    break;
                  }
                }
              }
            });
            this.createProperty("ROUTES", routeName, bundle, doc);
            // Add length property
            const lengthMm = b3d.lengthMm;
            this.createProperty("LENGTH", lengthMm.toPrecision(5), bundle, doc);
            // Add forced length property to Bundle if it exists
            this.addForcedLengthPropertyToBundle(doc, bundle, my_edge);
            // Add diameter property to bundle
            const diameterMm = b3d.diameter3dMm;
            this.createProperty(
              "DIAMETER",
              diameterMm.toPrecision(5),
              bundle,
              doc
            );
            // Add bendRadius property to bundle
            const bendRadiusMm = b3d.bendRadius;
            this.createProperty(
              "BENDRADIUS",
              bendRadiusMm.toPrecision(5),
              bundle,
              doc
            );
            // Add Partzone properties to bundle
            this.InsertPartZoneProperties(
              harness3dDesignSolution,
              pz,
              doc,
              bundle
            );

            //get CATIA SEGMENTS
            const catia_segments = this.getCatiaSegments(b3d);
            // add CATIA SEGMENTS property to bundle
            this.createProperty("CATIA_BNS", catia_segments, bundle, doc);
            if (this.option_branch_point) {
              bundle.appendChild(segments);
            }
            harness.appendChild(bundle);
            bundleIndex++;
            console.log("Bundle created : " + bundleDisName);
          } else {
            console.log("Node not found for edge: " + bundleDisName);
          }
        }
      });
    });
    // remove all useless bundles and node from graph (case of not connected x-ref)
    if (this.option_remove_small_branches)
      this.removeUselessBranches(harness, myGraph);
    // returning bundleObj for using it in post filtering
    return bundleObj;
  }
  //check if either of nodes of bundle is null
  checkNodeExtremities(my_node1: Pnode, my_node2: Pnode): boolean {
    return my_node1 != null && my_node2 != null;
  }
  //append bundle properties to bundle
  public addForcedLengthPropertyToBundle(doc: any, bundle: any, my_edge: any) {
    // create property forced length if needed
    if (my_edge.forced_length > 0) {
      const forced_lengthMm = my_edge.forced_length * 1000;
      this.createProperty(
        "FORCED_LENGTH",
        forced_lengthMm.toPrecision(5),
        bundle,
        doc
      );
    }
  }

  //method to convert forcedLength property from mm to m
  convertForcedLength(forcedLength_mm: number, my_edge: Pedge): number {
    if (forcedLength_mm > 0.001) {
      // converting forced length mm to m
      const forcedLength = forcedLength_mm / 1000;
      my_edge.forced_length = forcedLength;
    } else {
      my_edge.forced_length = -1;
    }

    return my_edge.forced_length;
  }

  // method dedicated to create the NODES of GRAPH  in the HX2ML file (from the CoreElec branch extremities)
  public createNodesHX2MLfile(
    doc: any,
    harness: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[],
    myGraph: Graph
  ) {
    let nodeIndex = 1;
    // scan all partzones of DS
    MyPartZones.forEach((pz) => {
      // scan all branches of PZ
      pz.b3d.forEach((b3d) => {
        if (this.isBranchValid(b3d, pz) === true) {
          // scan all extremities of branch
          b3d.b3dExt.forEach((b3dExt) => {
            // Create the node TAG
            const node = doc.createElement("node");
            const position = doc.createElement("Position");
            let nodeDisName = pz.userArea.name + "-";
            nodeDisName = nodeDisName + b3dExt.name;
            let xref_ignored = false;

            // check if the node can be simplified (case of X-REF)
            const pos_equal = b3dExt.name.search("=");

            if (pos_equal >= 0 && b3dExt.name.length == 7) {
              //gets x-ref corresponding to either pz
              const otherXrefDisName = this.getOtherXrefDisName(
                b3dExt,
                pos_equal,
                pz
              );
              console.log("otherXrefDisName : " + otherXrefDisName);
              // find the other node
              const other_node = myGraph.nodes.find(
                (o_node) => o_node.name === otherXrefDisName
              );
              //check if x-ref can be ignored
              xref_ignored = this.checkXRef(
                other_node,
                b3dExt,
                harness,
                harness3dDesignSolution
              );
            }

            // create the attributes linked XML node TAG
            node.setAttribute(
              "name",
              harness3dDesignSolution.adapDesignSolutionNumber +
                "_" +
                nodeDisName
            );
            node.setAttribute("displayName", nodeDisName);
            node.setAttribute("id", "node" + nodeIndex);
            node.setAttribute("B3DExt_id", +b3dExt.id);
            // in case of x-ref create short_name attribute
            if (nodeDisName.includes("-=")) {
              const shortName = nodeDisName.substring(
                nodeDisName.indexOf("=") + 1
              );
              node.setAttribute("shortname", shortName);
            }
            // Converting mm to m
            let x_m = b3dExt.electricalCoordinateX;
            x_m = x_m / 1000;
            const y_m = b3dExt.electricalCoordinateY / 1000;
            const z_m = b3dExt.electricalCoordinateZ / 1000;

            position.setAttribute("x", x_m.toPrecision(8));
            position.setAttribute("y", y_m.toPrecision(8));
            position.setAttribute("z", z_m.toPrecision(8));

            node.appendChild(position);
            //writes node to xml if not present already
            const write_node_in_xml = this.writeNodeinXML(
              myGraph,
              xref_ignored,
              nodeDisName
            );

            // write the node in XML file and store it in Graph
            if (write_node_in_xml) {
              const my_node = new Pnode();
              my_node.db_id = b3dExt.id;
              my_node.number = nodeIndex;
              my_node.name = nodeDisName;
              my_node.x = b3dExt.electricalCoordinateX;
              my_node.y = b3dExt.electricalCoordinateY;
              my_node.z = b3dExt.electricalCoordinateZ;
              myGraph.addNode(my_node);
              harness.appendChild(node);
              console.log("Node created : " + nodeDisName);
              nodeIndex++;
            }
          });
        }
      });
    });
  }
  //gets corresponding x-ref with respect to userArea and pz.
  getOtherXrefDisName(
    b3dExt: Branch3dExtremitySolutionModel,
    pos_equal: number,
    pz: PartZoneModel
  ): string {
    const userArea1 = b3dExt.name.substr(pos_equal + 1, 2);
    const userArea2 = b3dExt.name.substr(pos_equal + 3, 2);
    let otherXrefDisName = "";
    if (pz.userArea.name == userArea1) {
      otherXrefDisName = userArea2 + "-" + b3dExt.name;
    } else if (pz.userArea.name == userArea2) {
      otherXrefDisName = userArea1 + "-" + b3dExt.name;
    }
    return otherXrefDisName;
  }
  //checks if x-ref can be ignored with respect to other node and branch extremity
  checkXRef(
    other_node: Pnode,
    b3dExt: Branch3dExtremitySolutionModel,
    harness: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel
  ): boolean {
    let xref_ignored = false;
    if (other_node != null) {
      // check XREFs coordinates are matching

      const square_distance =
        Math.pow(other_node.x - b3dExt.electricalCoordinateX, 2) +
        Math.pow(other_node.y - b3dExt.electricalCoordinateY, 2) +
        Math.pow(other_node.z - b3dExt.electricalCoordinateZ, 2);

      // if XREFs coordinates are matching at 1 mm of distance
      if (square_distance < 1) {
        other_node.db_id2 = b3dExt.id;
        other_node.name = b3dExt.name;

        // we don't create new the xref node.
        // we modify the other xref node with a merge xref ID
        const other_node_id = "node" + other_node.number;

        const nodes_xml = harness.getElementsByTagName("node");

        let other_node_xml = null;
        for (let i = 0; i < nodes_xml.length; i++) {
          if (nodes_xml[i].getAttribute("id") === other_node_id) {
            other_node_xml = nodes_xml[i];
            break;
          }
        }

        if (other_node_xml != null) {
          other_node_xml.setAttribute(
            "name",
            harness3dDesignSolution.adapDesignSolutionNumber + "-" + b3dExt.name
          );
          other_node_xml.setAttribute("displayName", b3dExt.name);
          xref_ignored = true;
        }
      }
    }
    return xref_ignored;
  }
  //write node to xml
  //if nodes not present in Graph and if x_ref is ignored
  writeNodeinXML(
    myGraph: Graph,
    xref_ignored: boolean,
    nodeDisName: string
  ): boolean {
    let write_node_in_xml: boolean;

    if (myGraph.nodes.length == 0) {
      // Adding first node to the graph
      // create the nodes of the graph
      write_node_in_xml = true;
    } else if (!xref_ignored) {
      // Code for not adding nodes if they are already exists in the Graph
      if (myGraph.nodes.find((node) => node.name === nodeDisName)) {
        write_node_in_xml = false;
      } else {
        // create the nodes of the graph
        write_node_in_xml = true;
      }
    }
    return write_node_in_xml;
  }

  // method dedicated to created the backshell attached to the connector
  public createBackshellHX2MLfile(
    backshellName: string,
    doc: any,
    connector: any,
    finDS: FunctionalItem3dSolutionModel
  ) {
    let backshellIndex = 1;
    if (finDS.backshells && finDS.backshells.length > 0) {
      finDS.backshells.forEach((bckshell) => {
        const backshell = doc.createElement("backshell");
        console.log(
          "bckshell.backshellOrientationReference :: " +
            bckshell.backshellOrientationReference
        );
        let fin_name =
          finDS.fin.sequenceNumber + finDS.fin.circuit.letters + "-BACKSHELL";
        if (finDS.fin.suffix != null && finDS.fin.suffix != "")
          fin_name += finDS.fin.suffix;
        if (finDS.fin.appendedLetter != null && finDS.fin.appendedLetter != "")
          fin_name += "_" + finDS.fin.appendedLetter;
        backshellName += fin_name;
        backshell.setAttribute("name", backshellName);
        backshell.setAttribute("displayName", fin_name);
        backshell.setAttribute("partnumber", bckshell.partNumber3d);
        backshell.setAttribute("length", 0);
        console.log("Backshell created : ", bckshell.partNumber3d);

        this.createProperty("Backshell_Type", bckshell.type, backshell, doc);

        this.createProperty(
          "Clocking_Angle",
          bckshell.backshellOrientation,
          backshell,
          doc
        );

        connector.setAttribute(
          "backshellOrient",
          bckshell.backshellOrientation
        );

        this.createProperty(
          "Backshell_OrientationReference",
          bckshell.backshellOrientationReference,
          backshell,
          doc
        );

        this.createProperty(
          "PARTNUMBER",
          bckshell.partNumber3d,
          backshell,
          doc
        );

        connector.appendChild(backshell);
        backshellIndex++;
        console.log("Backshell created : " + backshellName);
      });
    }
  }

  // optimised query dedicated to find the list of routes attached to a FIN for a given set of FINs
  public findFinswithRoutes(
    Fin3DIds: number[]
  ): Promise<FunctionalItem3dSolutionModel[]> {
    const { Op } = require("sequelize");
    return FunctionalItem3dSolutionModel.findAll({
      attributes: ["id"],
      where: { id: { [Op.in]: Fin3DIds } },
      include: [
        {
          model: FunctionalItemModel,
          attributes: ["sequenceNumber", "suffix", "appendedLetter"],
          include: [
            {
              model: CircuitModel,
              attributes: ["letters"],
            },
          ],
        },
        {
          model: FunctionalItem3dSolutionPartZoneRelation,
          attributes: ["id"],
          include: [
            {
              model: RouteCategoryModel,
              attributes: ["name"],
            },
          ],
        },
      ],
    });
  }

  // Deprecated for perfo reasons: unitary query dedicated to find the list of routes for a given FIN
  public findFinwithRoutes(
    fin_id: number
  ): Promise<FunctionalItem3dSolutionModel> {
    return FunctionalItem3dSolutionModel.findOne({
      attributes: ["id"],
      where: { id: fin_id },
      include: [
        {
          model: FunctionalItem3dSolutionPartZoneRelation,
          attributes: ["id"],
          include: [
            {
              model: RouteCategoryModel,
              attributes: ["name"],
            },
          ],
        },
      ],
    });
  }

  // format a FIN name for a given FIN 3D solution
  public getFinName(finDS: FunctionalItem3dSolutionModel) {
    let fin_name = finDS.fin.sequenceNumber + finDS.fin.circuit.letters;
    // LS: suffix and appended letter are not mandatory for a FIN
    if (finDS.fin.suffix != null && finDS.fin.suffix != "")
      fin_name += finDS.fin.suffix;
    if (finDS.fin.appendedLetter != null && finDS.fin.appendedLetter != "")
      fin_name += "_" + finDS.fin.appendedLetter;
    return fin_name;
  }
  // function to format FIN_name and return linked info
  public getFinInfo(finDS: FunctionalItem3dSolutionModel) {
    let fin_name = "";
    let seqNo = "";
    const cktLetter = finDS.fin.circuit.letters;
    let suffix = "   ";
    let appLetter = "   ";
    // right-pad seqNo
    const seqLen = 4 - finDS.fin.sequenceNumber.length;
    for (let i = 0; i < seqLen; i++) {
      seqNo = seqNo + " ";
    }
    seqNo += finDS.fin.sequenceNumber;
    fin_name = seqNo + cktLetter;
    // left-pad Suffix(optional)
    if (finDS.fin.suffix != null && finDS.fin.suffix != "") {
      suffix = finDS.fin.suffix;
      const sufLen = 3 - finDS.fin.suffix.length;
      for (let i = 0; i < sufLen; i++) {
        suffix = suffix + " ";
      }
    }
    fin_name = fin_name + suffix;
    // right-pad appLetter(optional)
    if (finDS.fin.appendedLetter != null && finDS.fin.appendedLetter != "") {
      appLetter = "";
      const appLen = 3 - finDS.fin.appendedLetter.length;
      for (let i = 0; i < appLen; i++) {
        appLetter = appLetter + " ";
      }
      appLetter = appLetter + finDS.fin.appendedLetter;
      fin_name = fin_name + appLetter;
    }
    fin_name = fin_name.trim(); // to avoid unnecessary padding
    return { fin_name, seqNo, cktLetter, suffix, appLetter };
  }
  //function to get the FINs of the DS
  public collectFIN(MyPartZones: PartZoneModel[], Fin3DIds: number[]) {
    for (const pz of MyPartZones) {
      // scan all branches related to partzone
      for (const b3d of pz.b3d) {
        if (this.isBranchValid(b3d, pz) === true) {
          // search for find ds
          for (const b3dExt of b3d.b3dExt) {
            for (const finDs of b3dExt.finDs) {
              Fin3DIds.push(finDs.id);
            }
          }
        }
      }
    }
  }

  // if fin_name has VC_A==>inline_plug otherwise inline_jack
  public getConnectorType(fin_name: string, finckt: string): string {
    let type = "jack";
    if (fin_name.includes("VC")) {
      if (fin_name.includes("_")) {
        if (fin_name.includes("_A")) type = "inlineplug";
      } else type = "inlinejack";
    } else if (finckt === "VN") type = "inlineplug";
    return type;
  }
  //get list of routes for FIN and append the ROUTES to connector
  public addRouteforFINtoConnector(
    finDS2: FunctionalItem3dSolutionModel,
    doc: any,
    fin_name: string,
    connector: any
  ) {
    let list_of_routes = "";
    if (finDS2 != null && finDS2.FinPzRelations != null) {
      finDS2.FinPzRelations.forEach((FinPzRelations) => {
        FinPzRelations.effectiveRoutes.sort(this.compareRoutes);
        FinPzRelations.effectiveRoutes.forEach((route) => {
          if (list_of_routes == "") {
            list_of_routes += route.name;
          } else {
            list_of_routes += "," + route.name;
          }
        });
      });
      this.createProperty("ROUTES", list_of_routes, connector, doc);

      console.log("Routes for FIN " + fin_name + ": " + list_of_routes);
    }
  }

  //function to check if definitionZone and panel property exists fot the given finDs
  //if yes, add existing properties to connector
  public checkZoneandPanelProperty(
    finDS: FunctionalItem3dSolutionModel,
    doc: any,
    connector: any
  ) {
    if (finDS.definitionZone != null && finDS.definitionZone != "") {
      this.createProperty("ZONE", finDS.definitionZone, connector, doc);
    }

    if (finDS.panel != null && finDS.panel != "") {
      this.createProperty("PANEL", finDS.panel, connector, doc);
    }
  }

  //function to find matching nodes to b3dExt in graph and add as connector attribute
  public addNodesToConnector(
    myGraph: Graph,
    b3dExt: Branch3dExtremitySolutionModel,
    connector: any
  ) {
    const my_node = myGraph.nodes.find((node) => node.db_id === b3dExt.id);

    if (my_node != null) {
      connector.setAttribute("nodeid", "node" + my_node.number);
    } else {
      connector.setAttribute("nodeid", "null");
    }
  }
  //function to check if finckt === "VN" and set corresponding attribute
  public checkFinCkt(
    finckt: string,
    finDS: FunctionalItem3dSolutionModel,
    connector: any
  ) {
    if (finckt === "VN") {
      connector.setAttribute("partnumber", "NSAVN");
    } else connector.setAttribute("partnumber", finDS.partNumber3d);
  }
  //function to check connectorName, and add connector to wiringConnectivity
  //if connector added, increment connectorIndex to indicate connector count
  //returns connectorIndex
  public addConnector(
    connectorObj: any,
    connector: any,
    wiringConnectivity: any
  ): number {
    const connectorNameTable: string[] = connectorObj.connectorNameTable;
    const connectorName: string = connectorObj.connectorName;
    let connectorIndex: number = connectorObj.connectorIndex;

    if (connectorNameTable.indexOf(connectorName) < 0) {
      connectorNameTable.push(connectorName);
      wiringConnectivity.appendChild(connector);
      connectorIndex++;
      console.log("Connector created : " + connectorName);
      return connectorIndex;
    }
  }
  //function to add COMPDESC property to connector if b3dExt.type is not NULL
  public addCompDESCToConnector(
    b3dExt: Branch3dExtremitySolutionModel,
    doc: any,
    connector: any
  ) {
    if (b3dExt.type != null) {
      this.createProperty("COMPDESC", b3dExt.type.name, connector, doc);
    }
  }

  public createProperty(
    propertyName: any,
    propertyValue: any,
    parentProperty: any,
    doc: any
  ) {
    const property = doc.createElement("property");
    property.setAttribute("name", propertyName);
    property.setAttribute("val", propertyValue);
    parentProperty.appendChild(property);
  }
  // method dedicated to create the CONNECTORS  in the HX2ML file
  public async createConnectorHX2MLfile(
    doc: any,
    wiringConnectivity: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[],
    myGraph: Graph
  ) {
    let connectorIndex = 1;
    const connectorNameTable: string[] = [];
    const Fin3DIds: number[] = [];

    // perfo optimisation : request all FINs to DB with their routes in one shot
    // First collect all FIN for the DS
    this.collectFIN(MyPartZones, Fin3DIds);
    // Then request route information for each FIN in one SQL request to optimize the performances
    const finsDS2 = await this.findFinswithRoutes(Fin3DIds);

    for (const pz of MyPartZones) {
      // scan all branches related to partzone
      for (const b3d of pz.b3d) {
        if (this.isBranchValid(b3d, pz) === true) {
          // search for find ds
          for (const b3dExt of b3d.b3dExt) {
            for (const finDS of b3dExt.finDs) {
              const connector = doc.createElement("connector");
              let connectorName =
                harness3dDesignSolution.adapDesignSolutionNumber + "_";
              connectorName += pz.userArea.name + "-";
              connectorName += b3dExt.name + "-";
              // get formatted FIN
              const fin_name = this.getFinName(finDS); // retrieve connector_name
              const finInfo = this.getFinInfo(finDS);
              const dispFin = finInfo.fin_name; // retrieve dispFinName
              const finSeq = finInfo.seqNo;
              const finckt = finInfo.cktLetter;
              const finSuf = finInfo.suffix;
              const finappLetter = finInfo.appLetter;

              console.log("fin", fin_name);
              // condition to integrate InLine Connectors
              //function to extract the connector type from fin name and finckt code
              const type = this.getConnectorType(fin_name, finckt);

              let slot_name = finSeq + finckt + finSuf;
              slot_name = slot_name.trim();
              connectorName += fin_name;
              connector.setAttribute("name", connectorName);
              connector.setAttribute("displayName", dispFin);
              connector.setAttribute("id", "connector" + connectorIndex);

              //check FIN circuit code finckt and set partnumber attribute on connector
              //update the type property of connector if finckt === 'VN'
              this.checkFinCkt(finckt, finDS, connector);

              connector.setAttribute("slotname", slot_name);

              //Searches for nodes in the graph matching b3dExt and adds to connector
              this.addNodesToConnector(myGraph, b3dExt, connector);

              connector.setAttribute("type", type);

              const pin = doc.createElement("pin");
              pin.setAttribute("name", "Termination1");
              pin.setAttribute("id", "connector" + connectorIndex + ".pin1");
              connector.appendChild(pin);

              this.createProperty(
                "FIN_1_4_SEQUENCE_NUMBER",
                finSeq,
                connector,
                doc
              );

              this.createProperty("FIN_5_6_CIRCUIT", finckt, connector, doc);

              this.createProperty("FIN_7_9_SUFFIX", finSuf, connector, doc);

              this.createProperty(
                "FIN_10_12_APPENDED_LETTER",
                finappLetter,
                connector,
                doc
              );

              this.createProperty(
                "FIN_13_SUPPLEMENTARY_PART",
                " ",
                connector,
                doc
              );

              //check if b3dExt.type exists
              //if yes, set value of COMPDESC attribute
              this.addCompDESCToConnector(b3dExt, doc, connector);

              this.createProperty(
                "PARTNUMBER",
                finDS.partNumber3d,
                connector,
                doc
              );

              this.InsertPartZoneProperties(
                harness3dDesignSolution,
                pz,
                doc,
                connector
              );

              const finDS2 = finsDS2.find((fin2) => fin2.id === finDS.id);
              // perfo issue corrected:
              // const finDS2 = await this.findFinwithRoutes(finDS.id);

              // for each fin, get complementary route and append to connector
              this.addRouteforFINtoConnector(finDS2, doc, fin_name, connector);

              this.createProperty(
                "PRIORITY",
                finDS.mountingPriority,
                connector,
                doc
              );

              //if definitionZone and panel properties exists, add those properties to connector.
              this.checkZoneandPanelProperty(finDS, doc, connector);

              this.createBackshellHX2MLfile(
                connectorName,
                doc,
                connector,
                finDS
              );

              const connectorObj: any = {
                connectorNameTable: connectorNameTable,
                connectorName: connectorName,
                connectorIndex: connectorIndex,
              };
              //add connector to wiringconnectivity and return connectorIndex
              connectorIndex = this.addConnector(
                connectorObj,
                connector,
                wiringConnectivity
              );
            }
          }
        }
      }
    }
  }

  public findBranch(MyPartZones: PartZoneModel[], edge: Pedge) {
    const b3d1: Branch3DModel = null;
    let pz: PartZoneModel = null;
    for (pz of MyPartZones) {
      for (const br of pz.b3d) {
        if (br.id === edge.db_id) {
          return {
            branch: br,
            partZone: pz,
          };
        }
      }
    }
    return {
      branch: b3d1,
      partZone: pz,
    };
  }
  public modifyBundleXML(
    harness: any,
    bundleID: string,
    node_i: string,
    node_c: string
  ) {
    const bundle_xml = harness.getElementsByTagName("bundle");

    for (let i = 0; i < bundle_xml.length; i++) {
      if (bundle_xml[i].getAttribute("id") != bundleID) {
        if (bundle_xml[i].getAttribute("startNode") === node_c) {
          bundle_xml[i].setAttribute("startNode", node_i); // modify XML startNode
          const node_val = bundle_xml[i].getAttribute("startNode");
          console.log("startNode", node_val);
        } else if (bundle_xml[i].getAttribute("endNode") === node_c) {
          bundle_xml[i].setAttribute("endNode", node_i); // modify XML endNode
          const node_val = bundle_xml[i].getAttribute("endNode");
          console.log("endNode", node_val);
        }
      }
    }
  }
  // method to addLittleBranch when connector is linked to sveral branches
  public addLittleBranch(
    doc: any,
    harness: any,
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    MyPartZones: PartZoneModel[],
    myGraph: Graph
  ) {
    let nodeIndex = myGraph.nodes.length + 1;
    let bundleIndex = myGraph.edges.length + 1;
    let incr = 8000;
    let pz: PartZoneModel = null;
    myGraph.nodes.forEach((node) => {
      if (node.name.includes("EXT")) {
        // if node_c linked-connector
        const edges = myGraph.getConnectedEdges(node); // get_all connected edges from node_c
        if (edges.length > 1) {
          // if node_c has more than 1 edges
          // create a new Node in Graph and XML
          const my_node = new Pnode(); // creates node_i
          my_node.db_id = -1;
          my_node.number = nodeIndex;
          my_node.name = node.name.substring(0, 2) + "-DER" + incr;
          my_node.x = node.x;
          my_node.y = node.y;
          my_node.z = node.z;
          myGraph.addNode(my_node);
          console.log("Node created : " + my_node.name);
          // add node in XML
          const node_xml = doc.createElement("node");
          const position = doc.createElement("Position");
          node_xml.setAttribute(
            "name",
            harness3dDesignSolution.adapDesignSolutionNumber +
              "_" +
              my_node.name
          );
          node_xml.setAttribute("displayName", my_node.name);
          node_xml.setAttribute("id", "node" + nodeIndex);
          node_xml.setAttribute("B3DExt_id", +my_node.db_id);
          // Converting mm to m
          let x_m = my_node.x;
          x_m = x_m / 1000;
          const y_m = my_node.y / 1000;
          const z_m = my_node.z / 1000;
          position.setAttribute("x", x_m.toPrecision(8));
          position.setAttribute("y", y_m.toPrecision(8));
          position.setAttribute("z", z_m.toPrecision(8));
          node_xml.appendChild(position);
          harness.appendChild(node_xml);
          nodeIndex++;
          // create a new edge in Graph and XML
          const my_edge = new Pedge(my_node, node);
          my_edge.db_id = -1;
          my_edge.number = bundleIndex;
          my_edge.name = node.name.substring(0, 2) + "-BRA" + incr;
          my_edge.length = 0.001;
          my_edge.forced_length = -1;
          myGraph.addEdge(my_edge);
          console.log("Edge created : " + my_edge.name);
          // add edge in xml
          const bundle = doc.createElement("bundle");
          const bundleDisName = my_edge.name;
          bundle.setAttribute(
            "name",
            harness3dDesignSolution.adapDesignSolutionNumber +
              "_" +
              bundleDisName
          );
          bundle.setAttribute("displayName", bundleDisName);
          const bundleID = "bundle" + bundleIndex;
          bundle.setAttribute("id", bundleID);
          const startNode = "node" + my_node.number; // node_i
          const endNode = "node" + node.number; // node_c
          console.log("node_i", startNode);
          bundle.setAttribute("startNode", startNode);
          bundle.setAttribute("endNode", endNode);
          bundle.setAttribute("length", my_edge.length);

          // for other bundles attributes to append in XML ("bundleDiameter", "maxDiameter", "bendRadius")
          const bundlePropertyObj = this.addRadiusandDiameter(
            edges,
            MyPartZones
          );
          const diam3d = bundlePropertyObj.diam3d;
          const bendrad = bundlePropertyObj.bendrad;
          const routeName = bundlePropertyObj.routeName;

          pz = bundlePropertyObj.pz;

          const bundleDiameter = diam3d / 1000;
          const bendRadius = bendrad / 1000;
          bundle.setAttribute("bundleDiameter", bundleDiameter.toPrecision(5));
          bundle.setAttribute("maxDiameter", bundleDiameter.toPrecision(5));
          bundle.setAttribute("bendRadius", bendRadius.toPrecision(5));

          // Add PART property
          this.createProperty("CATIA_TYPE", "PART", bundle, doc);

          // Add Not Extractible property
          this.createProperty("NOT_EXTRACTIBLE", false, bundle, doc);

          // Add Routes property
          this.createProperty("ROUTES", routeName.toString(), bundle, doc);

          const lengthmm = my_edge.length * 1000;
          this.createProperty("LENGTH", lengthmm.toPrecision(5), bundle, doc);

          const diameterMm = diam3d;
          this.createProperty(
            "DIAMETER",
            diameterMm.toPrecision(5),
            bundle,
            doc
          );

          const bendRadiusMm = bendrad;
          this.createProperty(
            "BENDRADIUS",
            bendRadiusMm.toPrecision(5),
            bundle,
            doc
          );

          // add CATIA SEGMENTS property
          this.createProperty("CATIA_BNS", "", bundle, doc);

          this.InsertPartZoneProperties(
            harness3dDesignSolution,
            pz,
            doc,
            bundle
          );
          harness.appendChild(bundle);
          bundleIndex++;
          incr++;
          // re link all edges from node to New node
          for (const edge of edges) {
            if (edge.name != my_edge.name) {
              // except edge_i relink all
              edge.node2 = my_node;
            }
          }
          // modify corresponding sNode & eNode in XML;
          this.modifyBundleXML(harness, bundleID, startNode, endNode);
        }
      }
    });
    console.log("Checked condition for little branch");
  }
  //calculates bundle's physical properties ==> "bundleDiameter", "maxDiameter", "bendradius"
  public addRadiusandDiameter(
    edges: Pedge[],
    MyPartZones: PartZoneModel[]
  ): any {
    let diam3d = -1;
    let bendrad = -1;
    const routeName: string[] = [];
    let pz: PartZoneModel = null;
    let myObj = {};

    for (const edge of edges) {
      if (edge.db_id > 0) {
        const branchinfo = this.findBranch(MyPartZones, edge);
        const b3d1: Branch3DModel = branchinfo.branch;
        pz = branchinfo.partZone;

        if (b3d1 != null) {
          if (b3d1.diameter3dMm > diam3d) diam3d = b3d1.diameter3dMm; // for max diam3d
          if (b3d1.bendRadius > bendrad) bendrad = b3d1.bendRadius; // for max bendrad
          b3d1.effectiveRoutes.sort(this.compareRoutes);
          b3d1.effectiveRoutes.forEach((route) => {
            routeName.push(route.name);
          });
          routeName.sort();
        }
      }
    }
    myObj = {
      diam3d: diam3d,
      bendrad: bendrad,
      routeName: routeName,
      pz: pz,
    };

    return myObj;
  }

  public InsertPartZoneProperties(
    harness3dDesignSolution: Harness3dDesignSolutionModel,
    pz: PartZoneModel,
    doc: any,
    xml_elem: any
  ) {
    this.createProperty("USER_AREA", pz.userArea.name, xml_elem, doc);

    this.createProperty(
      "DS_NAME",
      harness3dDesignSolution.adapDesignSolutionNumber,
      xml_elem,
      doc
    );

    this.createProperty(
      "DS_VERSION",
      harness3dDesignSolution.adapDesignSolutionVersionNumber,
      xml_elem,
      doc
    );

    this.createProperty(
      "DS_ISSUE",
      harness3dDesignSolution.adapDesignSolutionIssueNumber,
      xml_elem,
      doc
    );

    this.createProperty("PZ_NAME", pz.name, xml_elem, doc);

    this.createProperty("PZ_VERSION", pz.version, xml_elem, doc);

    this.createProperty("PZ_ISSUE", pz.issue, xml_elem, doc);
  }

  public findConnectorFromXML(wiringConnectivity: any, fin_name: string) {
    const connector_nodes =
      wiringConnectivity.getElementsByTagName("connector");
    let connector_node = null;

    for (const node of connector_nodes) {
      if (node.getAttribute("displayName") === fin_name) {
        connector_node = node;
        break;
      }
    }
    return connector_node;
  }

  // test at least 2 other branches are connected and extractible branches
  private checkingForBranchesAndExtractible(
    ext_number: number,
    b3d: Branch3DModel,
    pz: PartZoneModel,
    isBranchValid: boolean
  ): boolean {
    let is_branch_valid = isBranchValid;
    let otherb3dExt: Branch3dExtremitySolutionModel;
    if (ext_number == 1 && b3d.b3dExt.length == 2) {
      otherb3dExt = b3d.b3dExt[1];
    } else if (ext_number == 2 && b3d.b3dExt.length == 2) {
      otherb3dExt = b3d.b3dExt[0];
    }
    if (otherb3dExt) {
      const number_extractible_brchs = this.countLinkedExtractibleBranches(
        otherb3dExt,
        pz
      );

      // atlaest one of the linked branches are extractible, branch is valid
      if (number_extractible_brchs >= 1) {
        console.log(
          "Non extractible branch ",
          b3d.name,
          " is kept in the harness"
        );
        is_branch_valid = true;
        return is_branch_valid;
      }
    }
  }

  // if branch is not extractible, is it valid?
  private checkBranchIsNotExtractable(
    b3d: Branch3DModel,
    pz: PartZoneModel,
    is_branch_valid: boolean
  ) {
    let ext_number = 0;
    b3d.b3dExt.forEach((b3dExt) => {
      ext_number += 1;
      // check if branch ext is a FIN
      if (b3dExt.finDs.length > 0) {
        // test at least 2 other branches are connected and extractible branches
        return this.checkingForBranchesAndExtractible(
          ext_number,
          b3d,
          pz,
          is_branch_valid
        );
      }
    });
  }

  // Check is branch is valid ( considering non extractible rules and user options)
  public isBranchValid(b3d: Branch3DModel, pz: PartZoneModel) {
    let is_branch_valid = false;
    // if branch is extractible it is
    if (b3d.notExtractible === false) {
      is_branch_valid = true;
    } else if (this.option_include_non_extractible_branch === "noNE") {
      console.log("noNE (only extractible) selected");
      is_branch_valid = false;
    }
    // branch non extractible and option is false
    else if (this.option_include_non_extractible_branch === "allNE") {
      console.log("allNE selected");
      is_branch_valid = true;
    }
    // branch non extractible and option is true
    else if (this.option_include_non_extractible_branch === "finNE") {
      console.log("finNE selected");
      console.log("branch is not extractible and linked to FIN ,we keep it");

      // if branch is not extractible, is it valid?
      return this.checkBranchIsNotExtractable(b3d, pz, is_branch_valid);
    } else if (this.option_include_non_extractible_branch === "finVTNE") {
      console.log("finVTNE selected");
      console.log("branch is not extractible and linked to VT we keep it");

      // if branch is not extractible, is it valid?
      let ext_number = 0;
      b3d.b3dExt.forEach((b3dExt) => {
        ext_number += 1;
        // check if branch ext is a FIN
        if (b3dExt.finDs.length > 0) {
          b3dExt.finDs.forEach((finDs) => {
            if (finDs.fin.circuit.letters === "VT") {
              is_branch_valid = this.checkingForBranchesAndExtractible(
                ext_number,
                b3d,
                pz,
                is_branch_valid
              );
            }
          });
        }
      });
    }
    return is_branch_valid;
  }

  public countLinkedExtractibleBranches(
    ext: Branch3dExtremitySolutionModel,
    pz: PartZoneModel
  ) {
    // scan all branches of PZ
    let number_extractible_brch = 0;
    pz.b3d.forEach((b3d) => {
      // scan all extremities of branch
      b3d.b3dExt.forEach((b3dExt) => {
        // filter on branch that have the same extremity
        if (b3dExt.id == ext.id) {
          if (!b3d.notExtractible) {
            number_extractible_brch += 1;
          }
        }
      });
    });
    return number_extractible_brch;
  }

  // method to suppress some nodes in XML ( case of small branches filtering)
  public removeNodeFromXML(harness: any, node: Pnode) {
    let removal_status = false;
    const node_id = "node" + node.number;

    const nodes_xml = harness.getElementsByTagName("node");
    let node_xml = null;
    for (let i = 0; i < nodes_xml.length; i++) {
      if (nodes_xml[i].getAttribute("id") === node_id) {
        node_xml = nodes_xml[i];
        break;
      }
    }
    if (node_xml) {
      harness.removeChild(node_xml);
      removal_status = true;
    }
    return removal_status;
  }

  // method to suppress some edges in XML ( case of small branches filtering)
  public removeEdgeFromXML(harness: any, edge: Pedge) {
    let removal_status = false;
    const edge_id = "bundle" + edge.number;
    const bundles_xml = harness.getElementsByTagName("bundle");
    let bundle_xml = null;
    for (let i = 0; i < bundles_xml.length; i++) {
      if (bundles_xml[i].getAttribute("id") === edge_id) {
        bundle_xml = bundles_xml[i];
        break;
      }
    }
    if (bundle_xml) {
      harness.removeChild(bundle_xml);
      removal_status = true;
    }
    return removal_status;
  }

  // this method is dedicated to suppress small branches on harness topology ( branches with to xref linked to non-present dynamic partzone )
  public removeUselessBranches(harness: any, myGraph: Graph) {
    console.log("Removing useless branches");
    const nodes_to_remove: Pnode[] = [];
    const edges_to_remove: Pedge[] = [];
    myGraph.nodes.forEach((node) => {
      // search all xref nodes on which a partzone is missing
      if (node.name.includes("-=") && node.name.length == 10) {
        // check the missing partzone is dynamic ( 2 letters, example: QA)
        const dynamic_pz = this.checkDynamicPZ(node);

        // if not-solved CrossRef node is searching a "Dynamic Part Zone", it can be suppressed with following conditions
        if (node["db_id2"] == null && dynamic_pz) {
          const my_edges = myGraph.getConnectedEdges(node);
          // xref node should be linked to only one edge
          this.suppressNode(
            my_edges,
            node,
            myGraph,
            nodes_to_remove,
            edges_to_remove
          );
        }
      }
    });
    // removing elements
    nodes_to_remove.forEach((node) => {
      // remove node from XML
      if (this.removeNodeFromXML(harness, node)) {
        console.log("node ", node.name + " removed from XML");
      }
      // remove node from graph
      if (myGraph.removeNode(node)) {
        console.log("node ", node.name + "removed from graph");
      }
    });
    edges_to_remove.forEach((edge) => {
      // remove edge from XML
      if (this.removeEdgeFromXML(harness, edge)) {
        console.log("edge ", edge.name + " removed from XML");
      }
      // remove edge from graph
      if (myGraph.removeEdge(edge)) {
        console.log("edge ", edge.name + " removed from graph");
      }
    });
    return true;
  }

  //check the last two characters (they represent the User Area)
  //if both characters are letters, the pz is dynamic
  public checkDynamicPZ(node: Pnode): boolean {
    let dynamic_pz = false;
    const userArea0 = node.name.substr(0, 2);
    const regexCrossRefDynamic = new RegExp("[A-Z]{2}");
    const pos_equal = node.name.search("=");
    if (pos_equal >= 0) {
      const userArea1 = node.name.substr(pos_equal + 1, 2);
      const userArea2 = node.name.substr(pos_equal + 3, 2);
      if (userArea0 == userArea1) {
        if (regexCrossRefDynamic.test(userArea2)) {
          dynamic_pz = true;
        }
      }
      if (userArea0 == userArea2) {
        if (regexCrossRefDynamic.test(userArea1)) {
          dynamic_pz = true;
        }
      }
    }
    return dynamic_pz;
  }

  //if x-ref node is connected to more than 1 branch
  //remove the node and corresponding edges
  public suppressNode(
    my_edges: Pedge[],
    node: Pnode,
    myGraph: Graph,
    nodes_to_remove: Pnode[],
    edges_to_remove: Pedge[]
  ) {
    if (my_edges.length == 1) {
      const my_edge = my_edges[0];
      // check the other node of the edge is linked to 3 edges
      let other_node = null;
      if (my_edge.node1 === node) {
        other_node = my_edge.node2;
      } else if (my_edge.node2 === node) {
        other_node = my_edge.node1;
      }
      let my_linked_edges = null;
      if (other_node != null)
        my_linked_edges = myGraph.getConnectedEdges(other_node);
      if (my_linked_edges && my_linked_edges.length >= 3) {
        nodes_to_remove.push(node);
        edges_to_remove.push(my_edge);
      }
    }
  }

  // function to be deleted (hard coded workaround to find a marker type)
  public isProtectionAFixingElement2(partNumberCovering: string) {
    let is_fixing_elem = false;
    if (
      partNumberCovering == "E0248A2-6H4" ||
      partNumberCovering == "E0248B2-6H4" ||
      partNumberCovering == "E0248A2-6H9" ||
      partNumberCovering == "E0248B2-6H9"
    ) {
      is_fixing_elem = true;
    }
    return is_fixing_elem;
  }

  // Deprecated due to performances optimisation - find marker info for one component
  public findMarker(partNumberCovering: string): Promise<ComponentModel> {
    //    make a query to DB to 'component' table in order to find the partNumber ( if not found return false)
    //    in the query make a jointure with 'marker_component table' on foreign key 'fk_component_id'
    return ComponentModel.findOne({
      attributes: ["id", "part_number"],
      where: { partNumber: partNumberCovering },
      include: [
        {
          model: MarkerComponentModel,
          attributes: ["id", "type", "fk_component_id"],
        },
      ],
    });
  }

  // Deprecated
  // this service will test the protection partNumber, will find it in Component table  & in marker_component table.
  // if it exist in the 2 tables, it will check the Type of marker_component which should contain 'Label' string.
  // If it is the case, the protection is a fixing element and service will return true.
  public async isProtectionAFixingElement(partNumberCovering: string) {
    let is_fixing_elem = false;
    console.log("check partNumberCovering: ", partNumberCovering);
    const componentFound: ComponentModel = await this.findMarker(
      partNumberCovering
    );
    // if a markerComponentModel object is found
    // if 'Type' field string contains 'Label' string inside,then the protection is a fixing element => return true
    if (componentFound != null) {
      if (
        componentFound.markerComponents != null &&
        componentFound.markerComponents.length == 1
      ) {
        const marker = componentFound.markerComponents[0];
        console.log(
          "partNumberCovering is marker: ",
          partNumberCovering,
          " ",
          marker.id
        );
        if (marker.type.search("Label") >= 0) {
          console.log("partNumberCovering is marker with label: ", marker.type);
          is_fixing_elem = true;
        }
      }
    }
    return is_fixing_elem;
  }

  // optimized method: for a given set of (protective covering) components, find in CE DB all related marker info
  public findMarkerInfos(ComponentIds: number[]): Promise<ComponentModel[]> {
    //    make a query to DB to 'component' table in order to find the partNumber ( if not found return false)
    //    in the query make a jointure with 'marker_component table' on foreign key 'fk_component_id'
    return ComponentModel.findAll({
      attributes: ["id", "part_number"],
      where: { id: ComponentIds },
      include: [
        {
          model: MarkerComponentModel,
          attributes: ["id", "type", "fk_component_id"],
        },
      ],
    });
  }

  // This service is optimized to process all components linked to protections in one shot, and to identify the ones that are Fixing Components.
  // For each component this service will find it in Component table  & in marker_component table.
  // if it exist in the 2 tables, it will check the Type of marker_component which should contain 'Label' string.
  // If it is the case, the protection is a fixing element and service will return it.
  public async getFixingElements(
    ComponentIds: number[]
  ): Promise<ComponentModel[]> {
    const fixingsFound: ComponentModel[] = [];
    // From Ids, find components with marker infos in DB
    const componentsFound: ComponentModel[] = await this.findMarkerInfos(
      ComponentIds
    );
    if (componentsFound != null && componentsFound.length > 0) {
      for (const value of componentsFound) {
        const componentFound = value;
        // if a markerComponentModel object is found
        if (
          componentFound.markerComponents != null &&
          componentFound.markerComponents.length == 1
        ) {
          const marker = componentFound.markerComponents[0];
          console.log(
            "partNumberCovering is marker: ",
            componentFound.partNumber,
            " ",
            marker.id
          );
          // if 'Type' field string contains 'Label' string inside,then the protection is a fixing element => return true
          if (marker.type.search("Label") >= 0) {
            console.log(
              "partNumberCovering is marker with label: ",
              marker.type
            );
            fixingsFound.push(componentFound);
          }
        }
      }
    }
    return fixingsFound;
  }
}
